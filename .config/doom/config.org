#+title: Doom Emacs Configuration
#+subtitle: The Methods, Management, and Menagerie@@latex:\\@@ of Madness@@latex: --- in meticulous detail@@
#+author: Kelvin Porter (and Tecosaur)
#+html_head: <link rel='shortcut icon' type='image/png' href='https://www.gnu.org/software/emacs/favicon.png'>
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+options: coverpage:yes
#+startup: fold

Tecosaur's config.org, with the parts that I do not need taken out to make it
much slimmer and a couple small things added.

* Intro
Customising an editor can be very rewarding ... until you have to leave it.
For years I have been looking for ways to avoid this pain.
Then I discovered [[https://github.com/cknadler/vim-anywhere][vim-anywhere]], and found that it had an Emacs companion,
[[https://github.com/zachcurry/emacs-anywhere][emacs-anywhere]]. To me, this looked most attractive.

Separately, online I have seen the following statement enough times I think it's a catchphrase
#+begin_quote
Redditor 1: I just discovered this thing, isn't it cool. \\
Redditor 2: Oh, there's an Emacs mode for that.
#+end_quote

This was enough for me to install Emacs, but I soon learned there are [[https://github.com/remacs/remacs#why-emacs][far more
compelling reasons]] to keep using it.

I tried out the =spacemacs= distribution a bit, but it wasn't quite to my liking.
Then I heard about =doom emacs= and thought I may as well give that a try.
TLDR; it's great.

Now I've discovered the wonders of literate programming, and am becoming more
settled by the day. This is both my config, and a cautionary tale (just replace
"Linux" with "Emacs" in the comic below).

** Why Emacs?

Emacs is [[https://www.eigenbahn.com/2020/01/12/emacs-is-no-editor][not a text editor]], this is a common misnomer. It is far more apt to
describe Emacs as /a Lisp machine providing a generic user-centric text
manipulation environment/. That's quite a mouthful.
In simpler terms one can think of Emacs as a platform for text-related
applications. It's a vague and generic definition because Emacs itself is
generic.

Good with text. How far does that go? A lot further than one initially thinks:
+ [[https://orgmode.org/][Task planning]]
+ [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][File management]]
+ [[https://github.com/akermu/emacs-libvterm][Terminal emulation]]
+ [[https://www.djcbsoftware.nl/code/mu/mu4e.html][Email client]]
+ [[https://www.gnu.org/software/tramp/][Remote server tool]]
+ [[https://magit.vc/][Git frontend]]
+ Web [[https://github.com/pashky/restclient.el][client]]/[[https://github.com/skeeto/emacs-web-server][server]]
+ and more...

Ideally, one may use Emacs as /the/ interface to perform =input → transform →
output= cycles, i.e. form a bridge between the human mind and information
manipulation.

*** The enveloping editor
Emacs allows one to do more in one place than any other application. Why is this
good?
+ Enables one to complete tasks with a consistent, standard set of keybindings,
  GUI and editing methods --- learn once, use everywhere
+ Reduced context-switching
+ Compressing the stages of a project --- a more centralised workflow can progress
  with greater ease
+ Integration between tasks previously relegated to different applications, but
  with a common subject --- e.g. linking to an email in a to-do list

Emacs can be thought of as a platform within which various elements of your
workflow may settle, with the potential for rich integrations between them --- a
/life/ IDE if you will.

Today, many aspects of daily computer usage are split between different
applications which act like islands, but this often doesn't mirror how we
/actually use/ our computers. Emacs, if one goes down the rabbit hole, can give
users the power to bridge this gap.

#+name: emacs-platform
#+begin_src dot :cmd circo :file misc/emacs-platform.svg :exports none
digraph {
graph [bgcolor="transparent"];
node  [shape="underline" penwidth="2" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
edge  [arrowhead=none color="#aaaaaa" penwidth="1.2"]
// nodes
"Task Managment" [color="#2ec27e"]
"Email" [color="#1c71d8"]
"Office suite" [color="#813d9c"]
"Code editor" [color="#f5c211"]
"Git client" [color="#e66100"]
// "News feed" [color="#c01c28"]
// "Personal Knowledge Base" [color="#986a44"]

"Task Managment" -> "Email"
"Task Managment" -> "Office suite"
"Task Managment" -> "Code editor"
"Task Managment" -> "Git client"
// "Task Managment" -> "News feed"
// "Task Managment" -> "Personal Knowledge Base"

"Email" -> "Office suite"
"Email" -> "Code editor"
"Email" -> "Git client"
// "Email" -> "Personal Knowledge Base"

"Office suite" -> "Code editor"
"Office suite" -> "Git client"
// "Office suite" -> "News feed"
// "Office suite" -> "Personal Knowledge Base"

"Code editor" -> "Git client"

// "News feed" -> "Personal Knowledge Base"
}
#+end_src

#+caption: Some sample workflow integrations that can be used within Emacs
#+attr_html: :class invertible :alt Graph of possible Emacs task integrations :style max-width:min(24em,100%)
#+attr_latex: :width 0.55\linewidth
[[file:misc/emacs-platform.svg]]

*** Some notably unique features
+ Recursive editing
+ Completely introspectable, with pervasive docstrings
+ Mutable environment, which can be incrementally modified
+ Functionality without applications
+ Client-server separation allows for a daemon, giving near-instant perceived
  startup time.

*** Issues
+ Emacs has irritating quirks
+ Some aspects are showing their age (naming conventions, APIs)
+ Emacs is ([[https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html][mostly]]) single-threaded, meaning that when something holds that
  thread up the whole application freezes
+ A few other nuisances

*** Teach a man to fish...
#+begin_quote
Give a man a fish, and you feed him for a day. Teach a man to fish, and you feed
him for a lifetime. --- Anne Isabella
#+end_quote

Most popular editors have a simple and pretty [[https://code.visualstudio.com/docs/getstarted/settings][settings interface]], filled with
check-boxes, selects, and the occasional text-box. This makes it easy for the
user to pick between common desirable behaviours. To me this is now like /giving
a man a fish/.

What if you want one of those 'check-box' settings to be only on in certain
conditions? Some editors have workspace settings, but that requires you to
manually set the value for /every single instance/. Urgh, [[https://github.com/microsoft/vscode/issues/93153][what]] [[https://github.com/microsoft/vscode/issues/93628][a]] [[https://github.com/microsoft/vscode/issues/5595][pain]].

What if you could set the value of that 'check-box' setting to be the result of
an arbitrary expression evaluated for each file? This is where an editor like
Emacs comes in.
Configuration for Emacs isn't a list of settings in JSON etc. it's *an executable
program which modifies the behaviour of the editor to suit your liking*.
This is 'teaching a man to fish'.

Emacs is built in the same language you configure it in (Emacs [[https://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp]], or [[https://www.gnu.org/software/emacs/manual/html_node/eintr/][elisp]]).
It comes with a broad array of useful functions for text-editing, and Doom adds
a few handy little convenience functions.

Want to add a keybinding to delete the previous line? It's as easy as
#+name: Keybinding to delete the previous line
#+begin_src emacs-lisp :tangle no
(map! "C-d"
      (cmd! (previous-line)
            (kill-line)
            (forward-line)))
#+end_src

How about another example, say you want to be presented with a list of currently
open /buffers/ (think files, almost) when you split the window. It's as simple as
#+name: Prompt for buffer after split
#+begin_src emacs-lisp :tangle no
(defadvice! prompt-for-buffer (&rest _)
  :after 'window-split (switch-to-buffer))
#+end_src

Want to test it out? You don't need to save and restart, you can just /evaluate
the expression/ within your current Emacs instance and try it immediately! This
editor is, after all, a Lisp interpreter.

Want to tweak the behaviour? Just re-evaluate your new version --- it's a
super-tight iteration loop.

** Editor comparison

Over the years I have tried out (spent at least a year using as my primary
editor) the following applications
- Python IDLE
- Komodo Edit
- Brackets
- VSCode
- and now, Emacs

I have attempted to quantify aspects of my impressions of them below.

#+plot: transpose:yes type:radar min:0 max:4 ticks:4 file:"misc/editor-comparison.svg"
| Editor      | Extensibility | Ecosystem | Ease of Use | Comfort | Completion | Performance |
|-------------+---------------+-----------+-------------+---------+------------+-------------|
| IDLE        |             1 |         1 |           3 |       1 |          1 |           2 |
| VSCode      |             3 |         3 |           4 |     3.5 |          4 |           3 |
| Brackets    |           2.5 |         2 |           3 |       3 |        2.5 |           2 |
| Emacs       |             4 |         4 |           2 |       4 |        3.5 |           3 |
| Komodo Edit |             2 |         1 |           3 |       2 |          2 |           2 |

#+attr_html: :class invertible :alt Radar chart comparing my thoughts on a few editors.
#+attr_latex: :options inkscapelatex=false
[[file:misc/editor-comparison.svg]]

** Notes for the unwary adventurer
If you like the look of this, that's marvellous, and I'm really happy that I've
made something which you may find interesting, however:
#+begin_warning
This config is /insidious/. Copying the whole thing blindly can easily lead to
undesired effects. I recommend copying chunks instead.
#+end_warning

If you are so bold as to wish to steal bits of my config (or if I upgrade and
wonder why things aren't working), here's a list of sections which rely on
external setup (i.e. outside of this config).

+ dictionary :: I've downloaded a custom [[http://app.aspell.com/create][SCOWL]] dictionary, which I use in [[*Ispell][ispell]].
  If this causes issues, just delete the src_elisp{(setq ispell-dictionary ...)}
  bit.

Oh, did I mention that I started this config when I didn't know any =elisp=, and
this whole thing is a hack job? If you can suggest any improvements, please do
so, no matter how much criticism you include I'll appreciate it :)

*** Extra Requirements
The lovely ~doom doctor~ is good at diagnosing most missing things, but here are a
few extras.
+ A [[https://www.tug.org/texlive/][LaTeX Compiler]] is required for the mathematics rendering performed in [[#org][Org]],
  and by [[*CalcTeX][CalcTeX]].
+ I use the [[https://overpassfont.org/][Overpass]] font as a go-to sans serif.
  It's used as my ~doom-variable-pitch-font~ and in the graph generated
  by [[*Roam][Roam]].
  I have chosen it because it possesses a few characteristics I consider
  desirable, namely:
  - A clean, and legible style. Highway-style fonts tend to be designed to be
    clear at a glance, and work well with a thicker weight, and this is inspired
    by /Highway Gothic/.
  - It's slightly quirky. Look at the diagonal cut on stems for example.
    Helvetica is a masterful design, but I like a bit more pizzazz now and then.
+ A few LSP servers. Take a look at [[file:init.el][init.el]] to see which modules have the ~+lsp~ flag.
+ The [[https://github.com/dandavison/delta/][Delta]] binary. It's packaged for some distributions but I installed it with
  #+begin_src shell :eval no :tangle (if (executable-find "delta") "no" "setup.sh")
cargo install git-delta
  #+end_src
+ The =theme-magic= package requires the ~wal~ (=pywal=) executable. If this is
  packaged for you, great! If not, it's just a quick ~pip install~ away.
  #+begin_src shell :eval no :tangle (if (executable-find "wal") "no" "setup.sh")
sudo python3 -m pip install pywal
  #+end_src

** Current Issues
*** Magit push in daemon
Quite often trying to push to a remote in the Emacs daemon produces as error like this:
#+begin_src fundamental
128 git … push -v origin refs/heads/master\:refs/heads/master
Pushing to git@github.com:tecosaur/emacs-config.git

fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
#+end_src
*** Unread emails doesn't work across Emacs instances
It would be nice if it did, so that I could have the Emacs-daemon hold the
active mu4e session, but still get that information. In this case I'd want to
change the action to open the Emacs daemon, but it should be possible.

This would probably involve hooking into the daemon's modeline update function
to write to a temporary file, and having a file watcher started in other Emacs
instances, in a similar manner to [[*Rebuild mail index while using mu4e][Rebuild mail index while using mu4e]].

* Rudimentary configuration
Make this file run (slightly) faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]]
for more info).
#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

#+begin_src shell :exports none :comments no :tangle-mode (identity #o755)
#!/bin/bash
#+end_src
** Personal Information
It's useful to have some basic personal information
#+begin_src emacs-lisp
(setq user-full-name "Kelvin Porter"
      user-mail-address "kporter@protonmail.com")
#+end_src
Apparently this is used by ~GPG~, and all sorts of other things.

Speaking of ~GPG~, I want to use =~/.authsource.gpg= instead of the default in
=~/.emacs.d=. Why? Because my home directory is already cluttered, so this won't
make a difference, and I don't want to accidentaly purge this file (I have done
src_shell{rm -rf~/.emac.d~ before}. I also want to cache as much as possible, as
my home machine is pretty safe, and my laptop is shutdown a lot.
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src
** Better defaults
*** Simple settings
Browsing the web and seeing [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]] and comparing with the values
shown by =SPC h v= and selecting what I thought looks good, I've ended up adding
the following:

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…")               ; Unicode ellispis are nicer than "...", and also save /precious/ space

(display-time-mode 1)                             ; Enable time in the mode-line

(if (equal "Battery status not available"
           (battery))
    (display-battery-mode 1)                        ; On laptops it's nice to know how much power you have
  (setq password-cache-expiry nil))               ; I can trust my desktops ... can't I? (no battery = desktop)

(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src
*** Frame sizing
It's nice to control the size of new frames, when launching Emacs that can be
done with src_shell{emacs -geometry 160x48}. After the font size adjustment
during initialisation this works out to be ~102x31~.

Thanks to hotkeys, it's easy for me to expand a frame to half/full-screen, so it
makes sense to be conservative with the sizing of new frames.

Then, for creating new frames within the same Emacs instance, we'll just set the
default to be something roughly 80% of that size.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src
*** Auto-customisations
By default changes made via a customisation interface are added to =init.el=.
I prefer the idea of using a separate file for this. We just need to change a
setting, and load it if it exists.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
*** Buffer defaults
I'd much rather have my new buffers in ~org-mode~ than ~fundamental-mode~, hence
#+begin_src emacs-lisp
;; (setq-default major-mode 'org-mode)
#+end_src
For some reason this + the mixed pitch hook causes issues with hydra and so I'll
just need to resort to =SPC b o= for now.
** Doom configuration
*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
Doom has this lovely /modular configuration base/ that takes a lot of work out of
configuring Emacs. Each module (when enabled) can provide a list of packages to
install (on ~doom sync~) and configuration to be applied. The modules can also
have flags applied to tweak their behaviour.

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

**** Structure
As you may have noticed by this point, this is a [[https://en.wikipedia.org/wiki/Literate_programming][literate]] configuration. Doom
has good support for this which we access though the ~literate~ module.

While we're in the src_elisp{:config} section, we'll use Dooms nicer defaults,
along with the bindings and smartparens behaviour (the flags aren't documented,
but they exist).
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Interface
There's a lot that can be done to enhance Emacs' capabilities.
I reckon enabling half the modules Doom provides should do it.

#+name: doom-completion
#+begin_src emacs-lisp
(company                     ; the ultimate code completion backend
 +childframe)                ; ... when your children are better than you
;;helm                       ; the *other* search engine for love and life
;;ido                        ; the other *other* search engine...
;;(ivy                         ; a search engine for love and life
;; +icons                      ; ... icons are nice
;; +prescient)                 ; ... I know what I want(ed)
vertico			     ; the search engine of the future
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
;;deft                       ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
doom-quit                    ; DOOM quit-message prompts when you quit Emacs
;;(emoji +unicode)             ; 🙂
;;fill-column                ; a `fill-column' indicator
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;hydra                      ; quick documentation for related commands
;;indent-guides              ; highlighted indent columns, notoriously slow
(ligatures +extra)           ; ligatures and symbols to make your code pretty again
;;minimap                    ; show a map of the code on the side
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
neotree                      ; a project drawer, like NERDTree for vim
ophints                      ; highlight the region an operation acts on
(popup                       ; tame sudden yet inevitable temporary windows
 +all                        ; catch all popups that start with an asterix
 +defaults)                  ; default popup rules
;;(tabs                      ; an tab bar for Emacs
;;  +centaur-tabs)           ; ... with prettier tabs
;;treemacs                     ; a project drawer, like neotree but cooler
;;unicode                    ; extended unicode support for various languages
vc-gutter                    ; vcs diff in the fringe
vi-tilde-fringe              ; fringe tildes to mark beyond EOB
(window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
(format)                     ; automated prettiness
;;god                        ; run Emacs commands without modifier keys
;;lispy                      ; vim for lisp, for people who don't like vim
multiple-cursors             ; editing in many places at once
;;objed                      ; text object editing for the innocent
;;parinfer                   ; turn lisp into python, sort of
rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type so I don't have to
;;word-wrap                  ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons)               ; making dired pretty [functional]
electric                     ; smarter, keyword-based electric-indent
;;(ibuffer icons)             ; interactive buffer management
(undo +tree)                 ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
;;eshell                     ; the elisp shell that works everywhere
;;shell                      ; simple shell REPL for Emacs
;;term                       ; basic terminal emulator for Emacs
vterm                        ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax                       ; tasing you for every semicolon you forget
(:if (executable-find "aspell") spell) ; tasing you for misspelling mispelling
grammar                      ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible                      ; a crucible for infrastructure as code
;;debugger                   ; FIXME stepping through code, to help you add bugs
;;direnv                     ; be direct about your environment
;;docker                       ; port everything to containers
;;editorconfig               ; let someone else argue about tabs vs spaces
;;ein                        ; tame Jupyter notebooks with emacs
(eval +overlay)              ; run code, run (also, repls)
;;gist                       ; interacting with github gists
(lookup                      ; helps you navigate your code and documentation
 +dictionary                 ; dictionary/thesaurus is nice
 +docsets)                   ; ...or in Dash docsets locally
lsp                          ; Language Server Protocol
(magit                       ; a git porcelain for Emacs
 +forge)                     ; interface with git forges
make                         ; run make tasks from Emacs
;;pass                       ; password manager for nerds
pdf                          ; pdf enhancements
;;prodigy                    ; FIXME managing external services & code builders
rgb                          ; creating color strings
;;taskrunner                 ; taskrunner for all your projects
;;terraform                  ; infrastructure as code
;;tmux                       ; an API for interacting with tmux
;;upload                       ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)	     ; improve compatibility with macOS
tty                          ; improve the terminal Emacs experience
#+end_src

**** Language support
We can be rather liberal with enabling support for languages as the associated
packages/configuration are (usually) only loaded when first opening an
associated file.

#+name: doom-lang
#+begin_src emacs-lisp
;;agda                       ; types of types of types of types...
;;beancount                  ; mind the GAAP
(cc +lsp)                         ; C/C++/Obj-C madness
;;clojure                    ; java with a lisp
;;common-lisp                ; if you've seen one lisp, you've seen them all
;;coq                        ; proofs-as-programs
;;crystal                    ; ruby at the speed of c
(csharp +lsp +dotnet)        ; unity, .NET, and mono shenanigans
data                         ; config/data formats
;;(dart +flutter)            ; paint ui and not much else
;;elixir                     ; erlang done right
;;elm                        ; care for a cup of TEA?
emacs-lisp                   ; drown in parentheses
;;erlang                     ; an elegant language for a more civilized age
;;ess                          ; emacs speaks statistics
;;factor                     ; for when scripts are stacked against you
;;faust                      ; dsp, but you get to keep your soul
;;fsharp                     ; ML stands for Microsoft's Language
;;fstar                      ; (dependent) types and (monadic) effects and Z3
;;gdscript                   ; the language you've waited for
;;(go +lsp)                  ; the hipster dialect
;; (haskell +lsp)            ; a language that's lazier than I am
;;hy                         ; readability of scheme w/ speed of python
;;idris                      ; a language you can depend on
json                         ; At least it ain't XML
;;(java +meghanada)          ; the poster child for carpal tunnel syndrome
(javascript +lsp)            ; all(hope(abandon(ye(who(enter(here))))))
;;(julia +lsp)                 ; a better, faster MATLAB
;;kotlin                     ; a better, slicker Java(Script)
(latex                       ; writing papers in Emacs has never been so fun
 +latexmk                    ; what else would you use?
 +cdlatex                    ; quick maths symbols
 +fold)                      ; fold the clutter away nicities
;;lean                       ; proof that mathematicians need help
;;ledger                     ; be audit you can be
;;lua                        ; one-based indices? one-based indices
markdown                       ; writing docs for people to ignore
;;nim                        ; python + lisp at the speed of c
;;nix                        ; I hereby declare "nix geht mehr!"
;;ocaml                      ; an objective camel
(org                         ; organize your plain life in plain text
 ;;+pretty                     ; yessss my pretties! (nice unicode symbols)
 +dragndrop                  ; drag & drop files/images into org buffers
 ;;+hugo                     ; use Emacs for hugo blogging
 +noter                      ; enhanced PDF notetaking
 +jupyter                    ; ipython/jupyter support for babel
 +pandoc                     ; export-with-pandoc support
 ;;+gnuplot                    ; who doesn't like pretty pictures
 ;;+pomodoro                 ; be fruitful with the tomato technique
 ;;+present                    ; using org-mode for presentations
 +roam2)                      ; wander around notes
;;php                        ; perl's insecure younger brother
;;plantuml                   ; diagrams for confusing people more
;;purescript                 ; javascript, but functional
(python +lsp +pyright +conda)       ; beautiful is better than ugly
;;qt                         ; the 'cutest' gui framework ever
;;racket                     ; a DSL for DSLs
;;raku                       ; the artist formerly known as perl6
;;rest                       ; Emacs as a REST client
;;rst                        ; ReST in peace
;;(ruby +rails)              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)                  ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala                      ; java, but good
;;scheme                       ; a fully conniving family of lisps
sh                           ; she sells {ba,z,fi}sh shells on the C xor
;;sml                        ; no, the /other/ ML
;;solidity                   ; do you need a blockchain? No.
;;swift                      ; who asked for emoji variables?
;;terra                      ; Earth and Moon in alignment for performance.
web                          ; the tubes
yaml                         ; JSON, but readable
;;zig                        ; C, but simpler
#+end_src

**** Everything in Emacs

#+name: doom-email
#+begin_src emacs-lisp
;;(:if (executable-find "mu") (mu4e +org +gmail))
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
;;calendar                   ; A dated approach to timetabling
;;emms                       ; Multimedia in Emacs is music to my ears
everywhere                   ; *leave* Emacs!? You must be joking.
;;irc                          ; how neckbeards socialize
(rss +org)                   ; emacs as an RSS reader
;;twitter                    ; twitter client https://twitter.com/vnought
#+end_src

*** Visual Settings
**** Font Face
Overpass and Inconsolata_dz is a great pairing. Second place here is Anything
and Dina, and third would be Recursive Sans and JetBrains Mono.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Dina" :style "Regular" :size 14)
      doom-big-font (font-spec :family "Overpass" :size 36)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 14)
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light))
#+end_src

#+attr_html: :class invertible :alt Screenshot of the fonts within Emacs.
[[https://tecosaur.com/lfs/emacs-config/screenshots/font-face.png]]

In addition to these fonts Alegreya is used as a
serifed proportional font used by =mixed-pitch-mode= for =writeroom-mode= with Org
files.

Because we care about how things look let's add a check to make sure we're told
if the system doesn't have any of those fonts.

#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts '("Dina" "Overpass" "JuliaMono" "IBM Plex Mono"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<detect-missing-fonts()>>
#+end_src

This way whenever fonts are missing, after Doom's UI has initialised, a warning
listing the missing fonts should appear for at least half a second.

**** Theme and modeline
I've been in a plain mood. Keeping the rest unless I'm not in a plain mood
sometime soon.
#+begin_src emacs-lisp
(setq doom-theme 'doom-monokai-spectrum)
(delq! t custom-theme-load-path)
#+end_src
However, by default ~red~ text is used in the ~modeline~, so let's make that orange
so I don't feel like something's gone /wrong/ when editing files.
#+begin_src emacs-lisp
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src
While we're modifying the modeline, =LF UTF-8= is the default file encoding, and
thus not worth noting in the modeline. So, let's conditionally hide it.
#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src
**** Miscellaneous
Relative line numbers are fantastic for knowing how far away line numbers are,
then =ESC 12 <UP>= gets you exactly where you think.
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

I'd like some slightly nicer default buffer names
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "► Doom"
      +doom-dashboard-name "► Doom")
#+end_src

*** Some helper macros
There are a few handy macros added by doom, namely
- ~load!~ for loading external ~.el~ files relative to this one
- ~use-package!~ for configuring packages
- ~add-load-path!~ for adding directories to the ~load-path~ where ~Emacs~ looks when
  you load packages with ~require~ or ~use-package~
- ~map!~ for binding new keys

*** Allow babel execution in CLI actions

In this config I sometimes generate code to include in my config.
This works nicely, but for it to work with =doom sync= et. al. I need to make sure
that Org doesn't try to confirm that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.
While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments none
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src
*** Asyncronous config tangling
Doom adds an =org-mode= hook ~+literate-enable-recompile-h~. This is a nice idea,
but it's too blocking for my taste. Since I trust my tangling to be fairly
straightforward, I'll just redefine it to a simpler, async, function.
#+begin_src emacs-lisp
(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (let ((default-directory doom-private-dir))
    (async-shell-command
     (format "emacs --batch --eval \"(progn (require 'org) (setq org-confirm-babel-evaluate nil) (org-babel-tangle-file \\\"%s\\\"))\""
             +literate-config-file))))
#+end_src
** Other things
*** Splash screen
Emacs can render an image as the splash screen, and [[https://github.com/MarioRicalde][@MarioRicalde]] came up with a
cracker! He's also provided me with a nice Emacs-style /E/. I was using the
blackhole image, but as I've stripped down the splash screen I've switched to
just using the /E/.

#+attr_latex: :width 0.2\linewidth
#+attr_html: :style width:20% :alt Fancy Emacs "E"
[[file:misc/splash-images/emacs-e.svg]]

Now we just make it theme-appropriate, and resize with the frame.

#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

Now the only thing missing is a an extra interesting line, whether that be some
corporate BS, an developer excuse, or a fun (useless) fact.

The following is rather long, but it essentially
+ fetches a phrase from an API
+ inserts it into the dashboard (asynchronously)
+ moves ~point~ to the phrase
+ re-uses the last phrase for requests within a few seconds of it being fetched

#+begin_src emacs-lisp
(defvar phrase-api-url
  (nth (random 3)
       '(("https://corporatebs-generator.sameerkumar.website/" :phrase)
         ("https://useless-facts.sameerkumar.website/api" :data)
         ("https://dev-excuses-api.herokuapp.com/" :text))))

(defmacro phrase-generate-callback (token &optional format-fn ignore-read-only callback buffer-name)
  `(lambda (status)
     (unless (plist-get status :error)
       (goto-char url-http-end-of-headers)
       (let ((phrase (plist-get (json-parse-buffer :object-type 'plist) (cadr phrase-api-url)))
             (inhibit-read-only ,(when (eval ignore-read-only) t)))
         (setq phrase-last (cons phrase (float-time)))
         (with-current-buffer ,(or (eval buffer-name) (buffer-name (current-buffer)))
           (save-excursion
             (goto-char (point-min))
             (when (search-forward ,token nil t)
               (with-silent-modifications
                 (replace-match "")
                 (insert ,(if format-fn format-fn 'phrase)))))
           ,callback)))))

(defvar phrase-last nil)
(defvar phrase-timeout 5)

(defmacro phrase-insert-async (&optional format-fn token ignore-read-only callback buffer-name)
  `(let ((inhibit-message t))
     (if (and phrase-last
              (> phrase-timeout (- (float-time) (cdr phrase-last))))
         (let ((phrase (car phrase-last)))
           ,(if format-fn format-fn 'phrase))
       (url-retrieve (car phrase-api-url)
                     (phrase-generate-callback ,(or token "\ufeff") ,format-fn ,ignore-read-only ,callback ,buffer-name))
       ;; For reference, \ufeff = Zero-width no-break space / BOM
       ,(or token "\ufeff"))))

(defun doom-dashboard-phrase ()
  (phrase-insert-async
   (progn
     (setq-local phrase-position (point))
     (mapconcat
      (lambda (line)
        (+doom-dashboard--center
         +doom-dashboard--width
         (with-temp-buffer
           (insert-text-button
            line
            'action
            (lambda (_)
              (setq phrase-last nil)
              (+doom-dashboard-reload t))
            'face 'doom-dashboard-menu-title
            'mouse-face 'doom-dashboard-menu-title
            'help-echo "Random phrase"
            'follow-link t)
           (buffer-string))))
      (split-string
       (with-temp-buffer
         (insert phrase)
         (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
         (fill-region (point-min) (point-max))
         (buffer-string))
       "\n")
      "\n"))
   nil t
   (progn
     (goto-char phrase-position)
     (forward-whitespace 1))
   +doom-dashboard-name))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

Lastly, the doom dashboard "useful commands" are no longer useful to me.
So, we'll disable them and then for a particularly /clean/ look disable
the modeline and ~hl-line-mode~, then also hide the cursor.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

At the end, we have a minimal but rather nice splash screen.

#+attr_html: :class invertible :alt The splash screen, just loaded.
[[https://tecosaur.com/lfs/emacs-config/screenshots/splash-screen.png]]

I haven't forgotten about the ASCII banner though! Once again we're going for
something simple.

#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '(",---.,-.-.,---.,---.,---."
            "|---'| | |,---||    `---."
            "`---'` ' '`---^`---'`---'"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat
                 line (make-string (max 0 (- longest-line (length line)))
                                   32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src


*** Emacs client wrapper
I frequently want to make use of Emacs while in a terminal emulator. To make
this easier, I can construct a few handy aliases.

However, a little convenience script in =~/.local/bin= can have the same effect,
be available beyond the specific shell I plop the alias in, then also allow me
to add a few bells and whistles --- namely:
+ Accepting stdin by putting it in a temporary file and immediately opening it.
+ Guessing that the =tty= is a good idea when ~$DISPLAY~ is unset (relevant with SSH
  sessions, among other things).
+ With a whiff of 24-bit color support, sets ~TERM~ variable to a =terminfo= that
  (probably) announces 24-bit color support.
+ Changes GUI =emacsclient= instances to be non-blocking by default (~--no-wait~),
  and instead take a flag to suppress this behaviour (~-w~).

I would use =sh=, but using arrays for argument manipulation is just too
convenient, so I'll raise the requirement to =bash=. Since arrays are the only
'extra' compared to =sh=, other shells like =csh= etc. should work too.

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments none
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
    case "$1" in
        -t | -nw | --tty)
            force_tty=true
            shift ;;
        -w | --wait)
            force_wait=true
            shift ;;
        -m | --mode)
            stdin_mode=" ($2-mode)"
            shift 2 ;;
        -h | --help)
            echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
            exit 0 ;;
        --*=*)
            set -- "$@" "${1%%=*}" "${1#*=}"
            shift ;;
        ,*)
            if [ "$#" = 0 ]; then
                break; fi
            args+=("$1")
            shift ;;
    esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
    unset 'args[-1]'
    TMP="$(mktemp /tmp/emacsstdin-XXX)"
    cat > "$TMP"
    args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
    # detect terminals with sneaky 24-bit support
    if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
        && [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
        if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
            termstub="${TERM%%-*}"; else
            termstub="${TERM#*-}"; fi
        if infocmp "$termstub-direct" >/dev/null 2>&1; then
            TERM="$termstub-direct"; else
            TERM="xterm-direct"; fi # should be fairly safe
    fi
    emacsclient --tty -create-frame --alternate-editor="" "${args[@]}"
else
    if ! $force_wait; then
        args+=(--no-wait); fi
    emacsclient -create-frame --alternate-editor="" "${args[@]}"
fi
#+end_src

Now, to set an alias to use =e= with magit, and then for maximum laziness we can
set aliases for the terminal-forced variants.
#+begin_src shell :tangle no
alias m='e --eval "(progn (magit-status) (delete-other-windows))"'
alias mt="m -t"
alias et="e -t"
#+end_src

* Package loading
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src
** Loading instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
This is where you install packages, by declaring them with the ~package!~
macro, then running ~doom refresh~ on the command line. You'll need to
restart Emacs for your changes to take effect! Or at least, run =M-x doom/reload=.

*Warning*: Don't disable core packages listed in =~/.emacs.d/core/packages.el=.
Doom requires these, and disabling them may have terrible side effects.

*** Packages in MELPA/ELPA/emacsmirror
To install ~some-package~ from MELPA, ELPA or emacsmirror:
#+begin_src emacs-lisp
(package! some-package)
#+end_src

*** Packages from git repositories
To install a package directly from a particular repo, you'll need to specify
a ~:recipe~. You'll find documentation on what ~:recipe~ accepts [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a ~PACKAGENAME.el~
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:
#+begin_src emacs-lisp
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

*** Disabling built-in packages
If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the ~:disable~ property:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src
You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't 'master' (which
our package manager can't deal with; see [[https://github.com/raxod502/straight.el/issues/279][raxod502/straight.el#279]])
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src
** General packages
*** Window management
#+begin_src emacs-lisp
(package! rotate :pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src
*** Fun
Every so often, you want everyone else to /know/ that you're typing, or just to
amuse oneself. Introducing: typewriter sounds!
#+begin_src emacs-lisp
(package! selectric-mode :pin "1840de71f7414b7cd6ce425747c8e26a413233aa")
#+end_src

With all our fancy Emacs themes, my terminal is missing out!
#+begin_src emacs-lisp
(package! theme-magic :pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
#+end_src

*** Features
**** CalcTeX
This is a nice extension to ~calc~

# TODO add calctex screenshot

#+begin_src emacs-lisp
(package! calctex :recipe (:host github :repo "johnbcoughlin/calctex"
                           :files ("*.el" "calctex/*.el" "calctex-contrib/*.el" "org-calctex/*.el" "vendor"))
  :pin "7fa2673c64e259e04aef684ccf09ef85570c388b")
#+end_src
**** Magit Delta
[[https://github.com/dandavison/delta/][Delta]] is a git diff syntax highlighter written in rust. The author also wrote a
package to hook this into the magit diff view. This requires the ~delta~ binary.
#+begin_src emacs-lisp
;; (package! magit-delta :recipe (:host github :repo "dandavison/magit-delta") :pin "1164a6c3e501e944f1a6a2e91f15374a193bb8d3")
#+end_src
**** Info colours
This makes manual pages nicer to look at :)
Variable pitch fontification + colouring

#+attr_html: :class invertible :style width:80% :alt Example info-colours page.
[[https://tecosaur.com/lfs/emacs-config/screenshots/info-colours.png]]

#+begin_src emacs-lisp
(package! info-colors :pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src
**** Large files
The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.
#+begin_src emacs-lisp
(package! vlf :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
  :pin "cc02f2533782d6b9b628cec7e2dcf25b2d05a27c" :disable t)
#+end_src
To make VLF available without delaying startup, we'll just load it in quiet moments.
#+begin_src emacs-lisp :tangle yes
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src
**** Definitions
Doom already loads =define-word=, and provides it's own definition service using
[[https://github.com/gromnitsky/wordnut][wordnut]]. However, using an offline dictionary possess a few compelling
advantages, namely:
+ speed
+ integration of multiple dictionaries
[[http://goldendict.org/][GoldenDict]] seems like the best option currently avalible, but lacks a CLI.
Hence, we'll fall back to [[https://dushistov.github.io/sdcv/][sdcv]] (a CLI version of StarDict) for now.
To interface with this, we'll use a my =lexic= package.

#+attr_html: :class invertible :alt Screenshot of the lexic-mode view of "literate"
[[https://tecosaur.com/lfs/emacs-config/screenshots/lexic.png]]

#+begin_src emacs-lisp
(package! lexic :recipe (:host github :repo "tecosaur/lexic"))
#+end_src

Given that a request for a CLI is the most upvoted issue on GitHub for
GoldenDict, it's likely we'll be able to switch from ~sdcv~ to that in the future.

Since GoldenDict supports StarDict files, I expect this will be a relatively
painless switch.
**** Calibre and ebook reading
For managing my ebooks, I'll hook into the well-established ebook library
manager [[https://calibre-ebook.com/][calibre]]. A number of Emacs clients for this exist, but this seems like a
good option.
#+begin_src emacs-lisp
(package! calibredb :pin "a3b04c0c37b1e8ceff2472e21a3579e64e944528")
#+end_src

Then for reading them, the only currently viable options seems to be [[https://depp.brause.cc/nov.el/][nov.el]].
#+begin_src emacs-lisp
(package! nov :pin "b3c7cc28e95fe25ce7b443e5f49e2e45360944a3")
#+end_src

**** Screenshots
This makes it a breeze to take lovely screenshots.
#+begin_src emacs-lisp
(package! screenshot :recipe (:host github :repo "tecosaur/screenshot"))
#+end_src

#+attr_html: :class invertible :alt Example screenshot.el screenshot
[[https://tecosaur.com/lfs/emacs-config/screenshots/screenshot.png]]

Some light configuring is all we need, so we can make use of the [[https://github.com/Calinou/0x0][0x0]] wrapper
file uploading script (which I've renamed to ~upload~).
#+begin_src emacs-lisp :tangle yes
(use-package! screenshot
  :defer t
  :config (setq screenshot-upload-fn "upload %s 2>/dev/null"))
#+end_src
**** Prettier page break lines
In some files, =^L= appears as a page break character. This isn't that visually
appealing, and Steve Purcell has been nice enough to make a package to display
these as horizontal rules.
#+begin_src emacs-lisp
(package! page-break-lines :recipe (:host github :repo "purcell/page-break-lines"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! page-break-lines
  :commands page-break-lines-mode
  :init
  (autoload 'turn-on-page-break-lines-mode "page-break-lines"))
#+end_src
** Language packages
*** LaTeX
For mathematical convenience, WIP
#+begin_src emacs-lisp
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets")
  :pin "e2b3edafd7aafa8c47833a70984d7404c607626c")
(package! laas :recipe (:host github :repo "tecosaur/LaTeX-auto-activating-snippets"))
#+end_src
And some basic config
#+begin_src emacs-lisp :tangle yes
(use-package! aas
  :commands aas-mode)

(use-package! laas
  :hook (LaTeX-mode . laas-mode)
  :config
  (defun laas-tex-fold-maybe ()
    (unless (equal "/" aas-transient-snippet-key)
      (+latex-fold-last-macro-a)))
  (add-hook 'aas-post-snippet-expand-hook #'laas-tex-fold-maybe))
#+end_src

*** Org Mode
**** Improve agenda/capture
The agenda is nice, but a souped up version is nicer.
#+begin_src emacs-lisp
(package! org-super-agenda :pin "f5e80e4d0da6b2eeda9ba21e021838fa6a495376")
#+end_src

Similarly ~doct~ (Declarative Org Capture Templates) seems to be a nicer way to
set up org-capture.
#+begin_src emacs-lisp
(package! doct
  :recipe (:host github :repo "progfolio/doct")
  :pin "8ac08633ae413a6605b6506d2739eece7475272e")
#+end_src
**** Visuals
Org tables aren't the prettiest thing to look at. This package is supposed to
redraw them in the buffer with box-drawing characters. Sounds like an
improvement to me! We'll make use of this with =writeroom-mode=.
#+begin_src emacs-lisp
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "474ad84a8fe5377d67ab7e491e8e68dac6e37a11")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src

For automatically toggling LaTeX fragment previews as the cursor moves in and
out of them there's this nice package
#+begin_src emacs-lisp
(package! org-fragtog :pin "0151cabc7aa9f244f82e682b87713b344d780c23")
#+end_src

Then for showing org formatting markers (=*/=~=)  when inside such a region, we
have =org-appear=.
#+begin_src emacs-lisp
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "0b3b029d5851c77ee792727b280f062eaf2c22c7")
#+end_src

There's this nice package that can provide nice syntax highlighting with LaTeX
exports.
#+begin_src emacs-lisp
(package! engrave-faces :recipe (:host github :repo "tecosaur/engrave-faces"))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! engrave-faces-latex
  :after ox-latex)
#+end_src
**** Extra functionality
Because of the /[[https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors][lovely variety in markdown implementations]]/ there isn't actually
such a thing a standard table spec ... or standard anything really. Because
~org-md~ is a goody-two-shoes, it just uses HTML for all these non-standardised
elements (a lot of them). So ~ox-gfm~ is handy for exporting markdown with all the
features that GitHub has.
#+begin_src emacs-lisp
(package! ox-gfm :pin "99f93011b069e02b37c9660b8fcb45dab086a07f")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! ox-gfm
  :after org)
#+end_src

Now and then citations need to happen
#+begin_src emacs-lisp
(package! org-ref :pin "3ca9beb744621f007d932deb8a4197467012c23a")
#+end_src

Came across this and ... it's cool
#+begin_src emacs-lisp
(package! org-graph-view :recipe (:host github :repo "alphapapa/org-graph-view") :pin "13314338d70d2c19511efccc491bed3ca0758170")
#+end_src

to make that right again, and this package makes that even easier to do.
#+begin_src emacs-lisp
(package! org-pandoc-import :recipe
  (:host github :repo "tecosaur/org-pandoc-import" :files ("*.el" "filters" "preprocessors")))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-pandoc-import
  :after org)
#+end_src

*** Systemd
For editing systemd unit files
#+begin_src emacs-lisp
(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src
*** Stan
Stan is probabilistic programming language written in =C++=. From my brief
exposure I think of it as a nicer =JAGS=. Though =Turing.jl= looks nicer yet...

Anyway, the [[https://github.com/stan-dev/stan-mode][stan-dev/stan-mode]] repository contains a number of packages for
working with Stan code. Let's grab them all.

#+begin_src emacs-lisp
(package! stan-mode :pin "9bb858b9f1314dcf1a5df23e39f9af522098276b")
(package! company-stan :pin "9bb858b9f1314dcf1a5df23e39f9af522098276b")
(package! eldoc-stan :pin "9bb858b9f1314dcf1a5df23e39f9af522098276b")
(package! flycheck-stan :pin "9bb858b9f1314dcf1a5df23e39f9af522098276b")
(package! stan-snippets :pin "9bb858b9f1314dcf1a5df23e39f9af522098276b")
#+end_src

*** Graphviz
Graphviz is a nice method of visualising simple graphs, based on plaintext
=.dot= / =.gv= files.
#+begin_src emacs-lisp
(package! graphviz-dot-mode :pin "3642a0a5f41a80c8ecef7c6143d514200b80e194")
#+end_src
*** Authinfo
#+begin_src emacs-lisp
(package! authinfo-color-mode
  :recipe (:host github :repo "tecosaur/authinfo-color-mode"))
#+end_src
Now we just need to load it appropriately.
#+begin_src emacs-lisp :tangle yes
(use-package! authinfo-color-mode
  :mode ("authinfo.gpg\\'" . authinfo-color-mode)
  :init (advice-add 'authinfo-mode :override #'authinfo-color-mode))
#+end_src
* Package configuration
** Abbrev mode
Thanks to [[https://emacs.stackexchange.com/questions/45462/use-a-single-abbrev-table-for-multiple-modes/45476#45476][use a single abbrev-table for multiple modes? - Emacs Stack Exchange]] I
have the following.
#+begin_src emacs-lisp
(use-package abbrev
  :init
  (setq-default abbrev-mode t)
  ;; a hook funtion that sets the abbrev-table to org-mode-abbrev-table
  ;; whenever the major mode is a text mode
  (defun tec/set-text-mode-abbrev-table ()
    (if (derived-mode-p 'text-mode)
        (setq local-abbrev-table org-mode-abbrev-table)))
  :commands abbrev-mode
  :hook
  (abbrev-mode . tec/set-text-mode-abbrev-table)
  :config
  (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))
  (setq save-abbrevs 'silently))
#+end_src
** Avy
What a wonderful way to jump to buffer positions, and it uses the QWERTY
home-row for jumping. Very convenient ... except I'm using Colemak.

#+begin_src emacs-lisp :tangle (if (= 0 (call-process "sh" nil nil nil "-c" "dmesg | grep -q 'ErgoDox'")) "yes" "no")
(after! avy
  ;; home row priorities: 8 6 4 5 - - 1 2 3 7
  (setq avy-keys '(?n ?e ?i ?s ?t ?r ?i ?a)))
#+end_src
** Calc
*** Defaults

Any sane person prefers radians and exact values.

#+begin_src emacs-lisp
(setq calc-angle-mode 'rad  ; radians are rad
      calc-symbolic-mode t) ; keeps expressions like \sqrt{2} irrational for as long as possible
#+end_src

#+attr_html: :class invertible :alt Demonstration of calc, prettified by calctex.
[[https://tecosaur.com/lfs/emacs-config/screenshots/calc-with-calctex.png]]

*** CalcTeX

We'd like to use CalcTeX too, so let's set that up, and fix some glaring
inadequacies --- why on earth would you commit a hard-coded path to an executable
that /only works on your local machine/, consequently breaking the package for
everyone else!?

#+begin_src emacs-lisp
(use-package! calctex
  :commands calctex-mode
  :init
  (add-hook 'calc-mode-hook #'calctex-mode)
  :config
  (setq calctex-additional-latex-packages "
\\usepackage[usenames]{xcolor}
\\usepackage{soul}
\\usepackage{adjustbox}
\\usepackage{amsmath}
\\usepackage{amssymb}
\\usepackage{siunitx}
\\usepackage{cancel}
\\usepackage{mathtools}
\\usepackage{mathalpha}
\\usepackage{xparse}
\\usepackage{arevmath}"
        calctex-additional-latex-macros
        (concat calctex-additional-latex-macros
                "\n\\let\\evalto\\Rightarrow"))
  (defadvice! no-messaging-a (orig-fn &rest args)
    :around #'calctex-default-dispatching-render-process
    (let ((inhibit-message t) message-log-max)
      (apply orig-fn args)))
  ;; Fix hardcoded dvichop path (whyyyyyyy)
  (let ((vendor-folder (concat (file-truename doom-local-dir)
                               "straight/"
                               (format "build-%s" emacs-version)
                               "/calctex/vendor/")))
    (setq calctex-dvichop-sty (concat vendor-folder "texd/dvichop")
          calctex-dvichop-bin (concat vendor-folder "texd/dvichop")))
  (unless (file-exists-p calctex-dvichop-bin)
    (message "CalcTeX: Building dvichop binary")
    (let ((default-directory (file-name-directory calctex-dvichop-bin)))
      (call-process "make" nil nil nil))))
#+end_src

*** Embedded calc

Embedded calc is a lovely feature which let's us use calc to operate on LaTeX
maths expressions. The standard keybinding is a bit janky however (=C-x * e=), so
we'll add a localleader-based alternative.

#+begin_src emacs-lisp
(map! :map calc-mode-map
      :after calc
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Embedded calc (toggle)" "E" #'calc-embedded)
(map! :map latex-mode-map
      :after latex
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
#+end_src

Unfortunately this operates without the (rather informative) calculator and
trail buffers, but we can advice it that we would rather like those in a side
panel.

#+begin_src emacs-lisp
(defvar calc-embedded-trail-window nil)
(defvar calc-embedded-calculator-window nil)

(defadvice! calc-embedded-with-side-pannel (&rest _)
  :after #'calc-do-embedded
  (when calc-embedded-trail-window
    (ignore-errors
      (delete-window calc-embedded-trail-window))
    (setq calc-embedded-trail-window nil))
  (when calc-embedded-calculator-window
    (ignore-errors
      (delete-window calc-embedded-calculator-window))
    (setq calc-embedded-calculator-window nil))
  (when (and calc-embedded-info
             (> (* (window-width) (window-height)) 1200))
    (let ((main-window (selected-window))
          (vertical-p (> (window-width) 80)))
      (select-window
       (setq calc-embedded-trail-window
             (if vertical-p
                 (split-window-horizontally (- (max 30 (/ (window-width) 3))))
               (split-window-vertically (- (max 8 (/ (window-height) 4)))))))
      (switch-to-buffer "*Calc Trail*")
      (select-window
       (setq calc-embedded-calculator-window
             (if vertical-p
                 (split-window-vertically -6)
               (split-window-horizontally (- (/ (window-width) 2))))))
      (switch-to-buffer "*Calculator*")
      (select-window main-window))))
#+end_src

** Centaur Tabs
We want to make the tabs a nice, comfy size (~36~), with icons. The modifier
marker is nice, but the particular default Unicode one causes a lag spike, so
let's just switch to an ~o~, which still looks decent but doesn't cause any
issues.
A 'active-bar' is nice, so let's have one of those. If we have it ~under~ needs us to
turn on ~x-underline-at-decent~ though. For some reason this didn't seem to work
inside the src_elisp{(after! ... )} block ¯\_(ツ)_/¯.
Then let's change the font to a sans serif, but the default one doesn't fit too
well somehow, so let's switch to 'P22 Underground Book'; it looks much nicer.
#+begin_src emacs-lisp
(after! centaur-tabs
  (centaur-tabs-mode -1)
  (setq centaur-tabs-height 36
        centaur-tabs-set-icons t
        centaur-tabs-modified-marker "o"
        centaur-tabs-close-button "×"
        centaur-tabs-set-bar 'above
        centaur-tabs-gray-out-icons 'buffer)
  (centaur-tabs-change-fonts "P22 Underground Book" 160))
;; (setq x-underline-at-descent-line t)
#+end_src
** Company
It's nice to have completions almost all the time, in my opinion. Key strokes
are just waiting to be saved!
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.5
        company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying.
#+end_src
Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src
*** Plain Text
~Ispell~ is nice, let's have it in ~text~, ~markdown~, and ~GFM~.
#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src
We then configure the dictionary we're using in [[*Ispell][Ispell]].
** Doom modeline
Very nice and pretty, however I think the PDF modeline could do with tweaking.
I raised [[https://github.com/seagle0128/doom-modeline/pull/425][an issue]] on this, however the response was basically "put your
preferences in your personal config, the current default is sensible" --- so
here we are.

First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                 'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

** Emacs Everywhere
#+begin_src emacs-lisp
(when (daemonp)
  (require 'spell-fu)
  (setq emacs-everywhere-major-mode-function #'org-mode
        emacs-everywhere-frame-name-format "Edit ∷ %s — %s")
  (require 'emacs-everywhere))
#+end_src
** Eros-eval
This makes the result of evals with =gr= and =gR= just slightly prettier. Every bit
counts right?
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ")
#+end_src
** EVIL
I don't use ~evil-escape-mode~, so I may as well turn it off, I've heard it
contributes a typing delay. I'm not sure it's much, but it is an extra
~pre-command-hook~ that I don't benefit from, so...
#+begin_src emacs-lisp
(after! evil-escape (evil-escape-mode -1))
#+end_src

When I want to make a substitution, I want it to be global more often than not
--- so let's make that the default.
#+begin_src emacs-lisp
(after! evil (setq evil-ex-substitute-global t)) ; I like my s/../.. to by global by default
#+end_src
** Info colours
#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)

(add-hook 'Info-mode-hook #'mixed-pitch-mode)
#+end_src

#+attr_html: :class invertible :alt Example colourised info page
[[https://tecosaur.com/lfs/emacs-config/screenshots/info-coloured.png]]
** Ispell
*** Downloading dictionaries
Let's get a nice big dictionary from [[http://app.aspell.net/create][SCOWL Custom List/Dictionary Creator]] with
the following configuration
- size :: 80 (huge)
- spellings :: British(-ise) and Australian
- spelling variants level :: 0
- diacritics :: keep
- extra lists :: hacker, roman numerals

**** Hunspell
#+begin_src shell :tangle (if (file-exists-p "/usr/share/myspell/en-custom.dic") "no" "setup.sh")
cd /tmp
curl -o "hunspell-en-custom.zip" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=hunspell'
unzip "hunspell-en-custom.zip"

sudo chown root:root en-custom.*
sudo mv en-custom.{aff,dic} /usr/share/myspell/
#+end_src
**** Aspell
#+begin_src shell :tangle (if (file-expand-wildcards "/usr/lib64/aspell*/en-custom.multi") "no" "setup.sh")
cd /tmp
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"

cd aspell6-en-custom
./configure && make && sudo make install
#+end_src
*** Configuration
#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")
#+end_src
Oh, and by the way, if ~company-ispell-dictionary~ is ~nil~, then
~ispell-complete-word-dict~ is used instead, which once again when ~nil~ is
~ispell-alternate-dictionary~, which at the moment maps to a plaintext version of
the above.

It seems reasonable to want to keep an eye on my personal dict, let's have it
nearby (also means that if I change the 'main' dictionary I keep my addition).
#+begin_src emacs-lisp
(setq ispell-personal-dictionary (expand-file-name ".ispell_personal" doom-private-dir))
#+end_src
** Magit
Magit is pretty nice by default. The diffs don't get any
syntax-highlighting-love though which is a bit sad. Thankfully
[[https://github.com/dandavison/magit-delta][dandavison/magit-delta]] exists, which we can put to use.
#+begin_src emacs-lisp
;; (after! magit
;;   (magit-delta-mode +1))
#+end_src
Unfortunately this seems to mess things up, which is something I'll want to look
into later.
** Projectile
Looking at documentation via =SPC h f= and =SPC h v= and looking at the source can
add package src directories to projectile. This isn't desirable in my opinion.
#+begin_src emacs-lisp
(setq projectile-ignored-projects '("~/" "/tmp" "~/.emacs.d/.local/straight/repos/"))
(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src
** Smart Parentheses
#+begin_src emacs-lisp
(sp-local-pair
 '(org-mode)
 "<<" ">>"
 :actions '(insert))
#+end_src
** Theme magic
Let's automatically update terminals on theme change (as long as ~pywal~ is available).

Unfortunately, as the theme is set on startup this causes the hook to be run
immediately. It would be nicer to /not/ have this add to our precious startup
time (around 0.4s last time I checked).
We can achieve this by deferring it with a short idle timer that should add the
hook /just after/ initialisation.

#+begin_src emacs-lisp :tangle (if (executable-find "wal") "yes" "no")
(run-with-idle-timer 0.1 nil (lambda () (add-hook 'doom-load-theme-hook 'theme-magic-from-emacs)))
#+end_src
** Tramp
Let's try to make tramp handle prompts better
#+begin_src emacs-lisp
(after! tramp
  (setenv "SHELL" "/bin/zsh"))
                                        ;(setq tramp-shell-prompt-pattern "\\(?:^\\|\\)[^]#$%>\n]*#?[]#$%>] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + 
#+end_src
*** Troubleshooting
In case the remote shell is misbehaving, here are some things to try
**** Zsh
There are some escape code you don't want, let's make it behave more considerately.
#+begin_src shell :eval no :tangle no
if [[ "$TERM" == "dumb" ]]; then
    unset zle_bracketed_paste
    unset zle
    PS1='$ '
    return
fi
#+end_src
** Which-key
Let's make this popup a bit faster
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5) ;; I need the help, I really do
#+end_src
I also think that having =evil-= appear in so many popups is a bit too verbose,
let's change that, and do a few other similar tweaks while we're at it.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
   ))
#+end_src

#+attr_html: :class invertible :alt Whichkey triggered on an evil motion
[[https://tecosaur.com/lfs/emacs-config/screenshots/whichkey-evil.png]]
** Writeroom
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :comments link
:END:
For starters, I think Doom is a bit over-zealous when zooming in
#+begin_src emacs-lisp
(setq +zen-text-scale 0.8)
#+end_src

Then, when using Org it would be nice to make a number of other aesthetic
tweaks. Namely:
+ Use a serifed variable-pitch font
+ Hiding headline leading stars
+ Using fleurons as headline bullets
+ Hiding line numbers
+ Removing outline indentation
+ Centring the text
+ Turning on ~org-pretty-table-mode~

#+begin_src emacs-lisp
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")
(after! writeroom-mode
  (defvar-local +zen--original-org-indent-mode-p nil)
  (defvar-local +zen--original-mixed-pitch-mode-p nil)
  (defvar-local +zen--original-solaire-mode-p nil)
  (defvar-local +zen--original-org-pretty-table-mode-p nil)
  (defun +zen-enable-mixed-pitch-mode-h ()
    "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
    (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
      (if writeroom-mode
          (progn
            (setq +zen--original-solaire-mode-p solaire-mode)
            (solaire-mode -1)
            (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
            (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
        (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1))
        (when +zen--original-solaire-mode-p (solaire-mode 1)))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-superstar-headline-bullets-list
            'org-superstar-remove-leading-stars
            'org-adapt-indentation)
  (add-hook 'writeroom-mode-enable-hook
            (defun +zen-prose-org-h ()
              "Reformat the current Org buffer appearance for prose."
              (when (eq major-mode 'org-mode)
                (setq display-line-numbers nil
                      visual-fill-column-width 60
                      org-adapt-indentation nil)
                (setq
                 +zen--original-org-indent-mode-p org-indent-mode
                 +zen--original-org-pretty-table-mode-p (bound-and-true-p org-pretty-table-mode))
                (org-indent-mode -1)
                (org-pretty-table-mode 1))))
  (add-hook 'writeroom-mode-disable-hook
            (defun +zen-nonprose-org-h ()
              "Reverse the effect of `+zen-prose-org'."
              (when (eq major-mode 'org-mode)
                (when +zen--original-org-indent-mode-p (org-indent-mode 1))
                ;; (unless +zen--original-org-pretty-table-mode-p (org-pretty-table-mode -1))
                ))))
#+end_src

#+attr_html: :class invertible :alt Writeroom applied to an Org file
[[https://tecosaur.com/lfs/emacs-config/screenshots/writeroom-and-org.png]]
** YASnippet
Nested snippets are good, enable that.
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src
* Applications
** Ebooks
=calibredb= lets us use calibre through Emacs, because who wouldn't want to use
something through Emacs?
#+begin_src emacs-lisp
(use-package! calibredb
  :commands calibredb
  :config
  (setq calibredb-root-dir "/hdd/doc/ebk/"
        calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir))
  (map! :map calibredb-show-mode-map
        :ne "?" #'calibredb-entry-dispatch
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "q" #'calibredb-entry-quit
        :ne "." #'calibredb-open-dired
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments)
  (map! :map calibredb-search-mode-map
        :ne [mouse-3] #'calibredb-search-mouse
        :ne "RET" #'calibredb-find-file
        :ne "?" #'calibredb-dispatch
        :ne "a" #'calibredb-add
        :ne "A" #'calibredb-add-dir
        :ne "c" #'calibredb-clone
        :ne "d" #'calibredb-remove
        :ne "D" #'calibredb-remove-marked-items
        :ne "j" #'calibredb-next-entry
        :ne "k" #'calibredb-previous-entry
        :ne "l" #'calibredb-virtual-library-list
        :ne "L" #'calibredb-library-list
        :ne "n" #'calibredb-virtual-library-next
        :ne "N" #'calibredb-library-next
        :ne "p" #'calibredb-virtual-library-previous
        :ne "P" #'calibredb-library-previous
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "S" #'calibredb-switch-library
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "v" #'calibredb-view
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "." #'calibredb-open-dired
        :ne "b" #'calibredb-catalog-bib-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "r" #'calibredb-search-refresh-and-clear-filter
        :ne "R" #'calibredb-search-clear-filter
        :ne "q" #'calibredb-search-quit
        :ne "m" #'calibredb-mark-and-forward
        :ne "f" #'calibredb-toggle-favorite-at-point
        :ne "x" #'calibredb-toggle-archive-at-point
        :ne "h" #'calibredb-toggle-highlight-at-point
        :ne "u" #'calibredb-unmark-and-forward
        :ne "i" #'calibredb-edit-annotation
        :ne "DEL" #'calibredb-unmark-and-backward
        :ne [backtab] #'calibredb-toggle-view
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-n" #'calibredb-show-next-entry
        :ne "M-p" #'calibredb-show-previous-entry
        :ne "/" #'calibredb-search-live-filter
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments))
#+end_src

Then, to actually read the ebooks we use =nov=.

#+attr_html: :class invertible :alt Excerpt of the GNU Emacs manual viewed through nov.el
[[https://tecosaur.com/lfs/emacs-config/screenshots/nov.png]]

#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)

  (defun doom-modeline-segment--nov-info ()
    (concat
     " "
     (propertize
      (cdr (assoc 'creator nov-metadata))
      'face 'doom-modeline-project-parent-dir)
     " "
     (cdr (assoc 'title nov-metadata))
     " "
     (propertize
      (format "%d/%d"
              (1+ nov-documents-index)
              (length nov-documents))
      'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 80
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)

    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)

    (setq-local mode-line-format
                `((:eval
                   (doom-modeline-segment--workspace-name))
                  (:eval
                   (doom-modeline-segment--window-number))
                  (:eval
                   (doom-modeline-segment--nov-info))
                  ,(propertize
                    " %P "
                    'face 'doom-modeline-buffer-minor-mode)
                  ,(propertize
                    " "
                    'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                    'display `((space
                                :align-to
                                (- (+ right right-fringe right-margin)
                                   ,(* (let ((width (doom-modeline--font-width)))
                                         (or (and (= width 1) 1)
                                             (/ width (frame-char-width) 1.0)))
                                       (string-width
                                        (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
                  (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src

** Newsfeed
RSS feeds are still a thing. Why not make use of them with =elfeed=.
I really like what [[https://github.com/fuxialexander/doom-emacs-private-xfu/tree/master/modules/app/rss][fuxialexander]] has going on, but I don't think I need a custom
module. Let's just try to patch on the main things I like the look of.

#+attr_html: :class invertible :alt Example elfeed entry
[[https://tecosaur.com/lfs/emacs-config/screenshots/elfeed.png]]

*** Keybindings
#+begin_src emacs-lisp
(map! :map elfeed-search-mode-map
      :after elfeed-search
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :n "q" #'+rss/quit
      :n "e" #'elfeed-update
      :n "r" #'elfeed-search-untag-all-unread
      :n "u" #'elfeed-search-tag-all-unread
      :n "s" #'elfeed-search-live-filter
      :n "RET" #'elfeed-search-show-entry
      :n "p" #'elfeed-show-pdf
      :n "+" #'elfeed-search-tag-all
      :n "-" #'elfeed-search-untag-all
      :n "S" #'elfeed-search-set-filter
      :n "b" #'elfeed-search-browse-url
      :n "y" #'elfeed-search-yank)
(map! :map elfeed-show-mode-map
      :after elfeed-show
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :nm "q" #'+rss/delete-pane
      :nm "o" #'ace-link-elfeed
      :nm "RET" #'org-ref-elfeed-add
      :nm "n" #'elfeed-show-next
      :nm "N" #'elfeed-show-prev
      :nm "p" #'elfeed-show-pdf
      :nm "+" #'elfeed-show-tag
      :nm "-" #'elfeed-show-untag
      :nm "s" #'elfeed-show-new-live-search
      :nm "y" #'elfeed-show-yank)
#+end_src
*** Usability enhancements
#+begin_src emacs-lisp
(after! elfeed-search
  (set-evil-initial-state! 'elfeed-search-mode 'normal))
(after! elfeed-show-mode
  (set-evil-initial-state! 'elfeed-show-mode   'normal))

(after! evil-snipe
  (push 'elfeed-show-mode   evil-snipe-disabled-modes)
  (push 'elfeed-search-mode evil-snipe-disabled-modes))
#+end_src
*** Visual enhancements
#+begin_src emacs-lisp
(after! elfeed

  (elfeed-org)
  (use-package! elfeed-link)

  (setq elfeed-search-filter "@1-week-ago +unread"
        elfeed-search-print-entry-function '+rss/elfeed-search-print-entry
        elfeed-search-title-min-width 80
        elfeed-show-entry-switch #'pop-to-buffer
        elfeed-show-entry-delete #'+rss/delete-pane
        elfeed-show-refresh-function #'+rss/elfeed-show-refresh--better-style
        shr-max-image-proportion 0.6
        rmh-elfeed-org-files (list (expand-file-name "elfeed.org" org-directory)))

  (add-hook! 'elfeed-show-mode-hook (hide-mode-line-mode 1))
  (add-hook! 'elfeed-search-update-hook #'hide-mode-line-mode)

  (defface elfeed-show-title-face '((t (:weight ultrabold :slant italic :height 1.5)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (defface elfeed-show-author-face `((t (:weight light)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (set-face-attribute 'elfeed-search-title-face nil
                      :foreground 'nil
                      :weight 'light)

  (defadvice! +rss-elfeed-wrap-h-nicer ()
    "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
    :override #'+rss-elfeed-wrap-h
    (setq-local truncate-lines nil
                shr-width 120
                visual-fill-column-center-text t
                default-text-properties '(line-height 1.1))
    (let ((inhibit-read-only t)
          (inhibit-modification-hooks t))
      (visual-fill-column-mode)
      ;; (setq-local shr-current-font '(:family "Merriweather" :height 1.2))
      (set-buffer-modified-p nil))
    (replace-string "\n" "" nil (point-min) (point-max)))

  (defun +rss/elfeed-search-print-entry (entry)
    "Print ENTRY to the buffer."
    (let* ((elfeed-goodies/tag-column-width 40)
           (elfeed-goodies/feed-source-column-width 30)
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (concat (mapconcat 'identity tags ",")))
           (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                           elfeed-goodies/tag-column-width 4))

           (tag-column (elfeed-format-column
                        tags-str (elfeed-clamp (length tags-str)
                                               elfeed-goodies/tag-column-width
                                               elfeed-goodies/tag-column-width)
                        :left))
           (feed-column (elfeed-format-column
                         feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width)
                         :left)))

      (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
      (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
      (insert (propertize title 'face title-faces 'kbd-help title))
      (setq-local line-spacing 0.2)))

  (defun +rss/elfeed-show-refresh--better-style ()
    "Update the buffer to match the selected entry, using a mail-style."
    (interactive)
    (let* ((inhibit-read-only t)
           (title (elfeed-entry-title elfeed-show-entry))
           (date (seconds-to-time (elfeed-entry-date elfeed-show-entry)))
           (author (elfeed-meta elfeed-show-entry :author))
           (link (elfeed-entry-link elfeed-show-entry))
           (tags (elfeed-entry-tags elfeed-show-entry))
           (tagsstr (mapconcat #'symbol-name tags ", "))
           (nicedate (format-time-string "%a, %e %b %Y %T %Z" date))
           (content (elfeed-deref (elfeed-entry-content elfeed-show-entry)))
           (type (elfeed-entry-content-type elfeed-show-entry))
           (feed (elfeed-entry-feed elfeed-show-entry))
           (feed-title (elfeed-feed-title feed))
           (base (and feed (elfeed-compute-base (elfeed-feed-url feed)))))
      (erase-buffer)
      (insert "\n")
      (insert (format "%s\n\n" (propertize title 'face 'elfeed-show-title-face)))
      (insert (format "%s\t" (propertize feed-title 'face 'elfeed-search-feed-face)))
      (when (and author elfeed-show-entry-author)
        (insert (format "%s\n" (propertize author 'face 'elfeed-show-author-face))))
      (insert (format "%s\n\n" (propertize nicedate 'face 'elfeed-log-date-face)))
      (when tags
        (insert (format "%s\n"
                        (propertize tagsstr 'face 'elfeed-search-tag-face))))
      ;; (insert (propertize "Link: " 'face 'message-header-name))
      ;; (elfeed-insert-link link link)
      ;; (insert "\n")
      (cl-loop for enclosure in (elfeed-entry-enclosures elfeed-show-entry)
               do (insert (propertize "Enclosure: " 'face 'message-header-name))
               do (elfeed-insert-link (car enclosure))
               do (insert "\n"))
      (insert "\n")
      (if content
          (if (eq type 'html)
              (elfeed-insert-html content base)
            (insert content))
        (insert (propertize "(empty)\n" 'face 'italic)))
      (goto-char (point-min))))

  )
#+end_src
*** Functionality enhancements
#+begin_src emacs-lisp
(after! elfeed-show
  (require 'url)

  (defvar elfeed-pdf-dir
    (expand-file-name "pdfs/"
                      (file-name-directory (directory-file-name elfeed-enclosure-default-dir))))

  (defvar elfeed-link-pdfs
    '(("https://www.jstatsoft.org/index.php/jss/article/view/v0\\([^/]+\\)" . "https://www.jstatsoft.org/index.php/jss/article/view/v0\\1/v\\1.pdf")
      ("http://arxiv.org/abs/\\([^/]+\\)" . "https://arxiv.org/pdf/\\1.pdf"))
    "List of alists of the form (REGEX-FOR-LINK . FORM-FOR-PDF)")

  (defun elfeed-show-pdf (entry)
    (interactive
     (list (or elfeed-show-entry (elfeed-search-selected :ignore-region))))
    (let ((link (elfeed-entry-link entry))
          (feed-name (plist-get (elfeed-feed-meta (elfeed-entry-feed entry)) :title))
          (title (elfeed-entry-title entry))
          (file-view-function
           (lambda (f)
             (when elfeed-show-entry
               (elfeed-kill-buffer))
             (pop-to-buffer (find-file-noselect f))))
          pdf)

      (let ((file (expand-file-name
                   (concat (subst-char-in-string ?/ ?, title) ".pdf")
                   (expand-file-name (subst-char-in-string ?/ ?, feed-name)
                                     elfeed-pdf-dir))))
        (if (file-exists-p file)
            (funcall file-view-function file)
          (dolist (link-pdf elfeed-link-pdfs)
            (when (and (string-match-p (car link-pdf) link)
                       (not pdf))
              (setq pdf (replace-regexp-in-string (car link-pdf) (cdr link-pdf) link))))
          (if (not pdf)
              (message "No associated PDF for entry")
            (message "Fetching %s" pdf)
            (unless (file-exists-p (file-name-directory file))
              (make-directory (file-name-directory file) t))
            (url-copy-file pdf file)
            (funcall file-view-function file))))))

  )
#+end_src

** Dictionary
We start off by loading =lexic=, then we'll integrate it into pre-existing
definition functionality (like ~+lookup/dictionary-definition~).
#+begin_src emacs-lisp
(use-package! lexic
  :commands lexic-search lexic-list-dictionary
  :config
  (map! :map lexic-mode-map
        :n "q" #'lexic-return-from-lexic
        :nv "RET" #'lexic-search-word-at-point
        :n "a" #'outline-show-all
        :n "h" (cmd! (outline-hide-sublevels 3))
        :n "o" #'lexic-toggle-entry
        :n "n" #'lexic-next-entry
        :n "N" (cmd! (lexic-next-entry t))
        :n "p" #'lexic-previous-entry
        :n "P" (cmd! (lexic-previous-entry t))
        :n "E" (cmd! (lexic-return-from-lexic) ; expand
                     (switch-to-buffer (lexic-get-buffer)))
        :n "M" (cmd! (lexic-return-from-lexic) ; minimise
                     (lexic-goto-lexic))
        :n "C-p" #'lexic-search-history-backwards
        :n "C-n" #'lexic-search-history-forwards
        :n "/" (cmd! (call-interactively #'lexic-search))))
#+end_src

Now let's use this instead of wordnet.
#+begin_src emacs-lisp
(defadvice! +lookup/dictionary-definition-lexic (identifier &optional arg)
  "Look up the definition of the word at point (or selection) using `lexic-search'."
  :override #'+lookup/dictionary-definition
  (interactive
   (list (or (doom-thing-at-point-or-region 'word)
             (read-string "Look up in dictionary: "))
         current-prefix-arg))
  (lexic-search identifier nil nil t))
#+end_src
* Language configuration
** General
*** File Templates
For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
need to have a template assigned.
#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src
** Plaintext
It's nice to see ANSI colour codes displayed
#+begin_src emacs-lisp
(after! text-mode
  (add-hook! 'text-mode-hook
             ;; Apply ANSI color codes
             (with-silent-modifications
               (ansi-color-apply-on-region (point-min) (point-max)))))
#+end_src
** Org Mode
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:
:intro:
I really like org mode, I've given some thought to why, and below is the result.

#+attr_latex: :align *{8}{p{0.105\linewidth}} :font \small
#+plot: transpose:yes type:radar min:0 max:4 file:"misc/document-format-comparison.svg"
| Format            | Fine-grained control | Initial ease of use | Syntax simplicity | Editor Support | Integrations | Ease-of-referencing | Versatility |
|-------------------+----------------------+---------------------+-------------------+----------------+--------------+---------------------+-------------|
| Word              |                    2 |                   4 |                 4 |              2 |            3 |                   2 |           2 |
| LaTeX             |                    4 |                   1 |                 1 |              3 |            2 |                   4 |           3 |
| Org Mode          |                    4 |                   2 |               3.5 |              1 |            4 |                   4 |           4 |
| Markdown          |                    1 |                   3 |                 3 |              4 |            3 |                   3 |           1 |
| Markdown + Pandoc |                  2.5 |                 2.5 |               2.5 |              3 |            3 |                   3 |           2 |

#+attr_html: :class invertible :alt Radar chart comparing my opinions of document formats.
#+attr_latex: :options inkscapelatex=false
[[file:misc/document-format-comparison.svg]]

Beyond the elegance in the markup language, tremendously rich integrations with
Emacs allow for some fantastic [[https://orgmode.org/features.html][features]], such as what seems to be the best
support for [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] of any currently available technology.

#+name: Literate programming workflow
#+attr_html: :style line-height:1.13;
#+begin_example
      ╭─╴Code╶─╮            ╭─╴Raw Code╶─▶ Computer
Ideas╺┥        ┝━▶ Org Mode╺┥
      ╰─╴Text╶─╯            ╰─╴Document╶─▶ People
#+end_example

An =.org= file can contain blocks of code (with [[https://en.wikipedia.org/wiki/Noweb][noweb]] templating support), which
can be [[https://orgmode.org/manual/Extracting-Source-Code.html][tangled]] to dedicated source code files, and [[https://orgmode.org/manual/Extracting-Source-Code.html][woven]] into a document
(report, documentation, presentation, etc.) through various (/extensible/) methods.
These source blocks may even create images or other content to be included in
the document, or generate source code.

#+name: Example Org Flowchart
#+attr_html: :style line-height:1.13;
#+begin_example
                   ╭───────────────────────────────────▶ .pdf ⎫
                  pdfLaTeX ▶╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╮                 ⎪
                   ╿     ╿                  ┊                 ⎪
                   │     ┊                  ┊                 ⎪
                 .tex    ┊                  ┊                 ⎪
                   ╿     ┊                  ┊                 ⎪
                ╭──┴╌╌╮  ┊                  ┊ style.scss      ⎬ Weaving
graphc.png ─╮   │  embedded TeX             ┊      ╽          ⎪ (Documents)
image.jpeg ─┤ filters   ╿                   ┊    .css         ⎪
            ╎     ╿     ┊                   ┊     ▾╎          ⎪
figure.png╶─╧─▶ PROJECT.ORG ▶───╴filters╶───╧──────╪──▶ .html ⎪
     ╿           ╿┊ ║ │ ╰╌╌╌▷╌╌ embedded html ▶╌╌╌╌╯          ⎪
     ├╌╌╌╌╌╌╌▷╌╌╌╯┊ ║ │                                       ⎪
    result╶╌╌╌╌╌╮ ┊ ║ ├──────╴filters╶────────────────▶ .txt  ⎪
     ┊▴         ┊ ┊ ║ │                                       ⎪
    execution   ┊ ┊ ║ ╰──────╴filters╶────────────────▶ .md   ⎭
     ┊▴         ┊ ┊ ║
    code blocks◀╯ ┊ ╟─────────────────────────────────▶ .c    ⎫
     ╰╌╌╌╌◁╌╌╌╌╌╌╌╯ ╟─────────────────────────────────▶ .sh   ⎬ Tangling
                    ╟─────────────────────────────────▶ .hs   ⎪ (Code)
                    ╙─────────────────────────────────▶ .el   ⎭
#+end_example
:end:

Finally, because this section is fairly expensive to initialise, we'll wrap it
in an src_elisp{(after! ...)} block.
#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
  )
#+end_src
*** System config
**** Mime types
Org mode isn't recognised as it's own mime type by default, but that can easily
be changed with the following file. For system-wide changes try
~/usr/share/mime/packages/org.xml~.
#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments none
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src
What's nice is that Papirus [[https://github.com/PapirusDevelopmentTeam/papirus-icon-theme/commit/a10fb7f2423d5e30b9c4477416ccdc93c4f3849d][now]] has an icon for =text/org=.
One simply needs to refresh their mime database
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src
Then set Emacs as the default editor
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "emacs-client.desktop\n") "no" "setup.sh")
xdg-mime default emacs.desktop text/org
#+end_src
**** Git diffs
Protesilaos wrote a [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][very helpful article]] in which he explains how to change the
git diff chunk heading to something more useful than just the immediate line
above the hunk --- like the parent heading.

This can be achieved by first adding a new diff mode to git in =~/.config/git/attributes=
#+begin_src fundamental
,*.org   diff=org
#+end_src

Then adding a regex for it to =~/.config/git/config=
#+begin_src gitconfig
[diff "org"]
	xfuncname = "^(\\*+ +.*)$"
#+end_src

**** Development
Testing patches from the ML is currently more hassle than it needs to be. Let's
change that.
#+begin_src emacs-lisp
(defvar org-ml-target-dir "~/.emacs.d/.local/straight/repos/org-mode/")
(defvar org-ml-max-age 600
  "Maximum permissible age in seconds.")
(defvar org-ml--cache-timestamp 0)
(defvar org-ml--cache nil)

(defun org-ml-current-patches ()
  "Get the currently open patches, as a list of alists.
Entries of the form (subject . id)."
  (delq nil
        (mapcar
         (lambda (entry)
           (unless (plist-get entry :fixed)
             (cons
              (format "%-8s  %s"
                      (propertize
                       (replace-regexp-in-string "T.*" ""
                                                 (plist-get entry :date))
                       'face 'font-lock-doc-face)
                      (propertize
                       (replace-regexp-in-string "\\[PATCH\\] ?" ""
                                                 (plist-get entry :summary))
                       'face 'font-lock-keyword-face))
              (plist-get entry :id))))
         (with-current-buffer (url-retrieve-synchronously "https://updates.orgmode.org/data/patches")
           (json-parse-buffer :object-type 'plist)))))

(defun org-ml-select-patch-thread ()
  "Find and apply a proposed Org patch."
  (interactive)
  (let ((current-workspace (+workspace-current))
        (patches (progn
                   (when (or (not org-ml--cache)
                             (> (- (float-time) org-ml--cache-timestamp)
                                org-ml-max-age))
                     (setq org-ml--cache (org-ml-current-patches)
                           org-ml--cache-timestamp (float-time)))
                   org-ml--cache))
        msg-id)
    (consult--read "Thread: "
              patches
              :action (lambda (m) (setq msg-id (cdr m))))
    (+workspace-switch +mu4e-workspace-name)
    (mu4e-view-message-with-message-id msg-id)
    (add-to-list 'mu4e-view-actions
                 (cons "apply patch to org" #'org-ml-transient-mu4e-action))))

(defun org-ml-transient-mu4e-action (msg)
  (setq mu4e-view-actions
        (delete (cons "apply patch to org" #'org-ml-transient-mu4e-action)
                mu4e-view-actions))
  (+workspace/other)
  (magit-status org-ml-target-dir)
  (with-current-buffer (get-buffer-create "*Shell: Org apply patches*")
    (erase-buffer)
    (let ((default-directory org-ml-target-dir))
      (shell-command
       (format "git am %s"
               (shell-quote-argument (mu4e-message-field msg :path)))
       (current-buffer))
      (magit-refresh))
    (when (string-match-p "Error\\|failed" (buffer-string))
      (+popup/buffer))))
#+end_src
*** Behaviour
**** Tweaking defaults
#+begin_src emacs-lisp
(setq org-directory "~/doc/org/"                      ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
      org-export-in-background t                  ; run export processes in external emacs process
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{}        ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
      org-re-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")
#+end_src
I also like the src_elisp{:comments} header-argument, so let's make that a
default.
#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

By default, ~visual-line-mode~ is turned =on=, and ~auto-fill-mode~ =off= by a hook.
However this messes with tables in Org-mode, and other plaintext files (e.g.
markdown, \LaTeX) so I'll turn it off for this, and manually enable it for more
specific modes as desired.
#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

There also seem to be a few keybindings which use =hjkl=, but miss arrow key equivalents.
#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src
**** Extra functionality
***** Org buffer creation
Let's also make creating an org buffer just that little bit easier.
#+begin_src emacs-lisp :tangle yes :noweb-ref none
(evil-define-command evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)))))
(map! :leader
      (:prefix "b"
       :desc "New empty ORG buffer" "o" #'evil-buffer-org-new))
#+end_src
***** List bullet sequence
I think it makes sense to have list bullets change with depth
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src
***** Citation
Occasionally I want to cite something.
#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :config
  (defadvice! org-ref-open-bibtex-pdf-a ()
    :override #'org-ref-open-bibtex-pdf
    (save-excursion
      (bibtex-beginning-of-entry)
      (let* ((bibtex-expand-strings t)
             (entry (bibtex-parse-entry t))
             (key (reftex-get-bib-field "=key=" entry))
             (pdf (or
                   (car (-filter (lambda (f) (string-match-p "\\.pdf$" f))
                                 (split-string (reftex-get-bib-field "file" entry) ";")))
                   (funcall org-ref-get-pdf-filename-function key))))
        (if (file-exists-p pdf)
            (org-open-file pdf)
          (ding)))))
  (defadvice! org-ref-open-pdf-at-point-a ()
    "Open the pdf for bibtex key under point if it exists."
    :override #'org-ref-open-pdf-at-point
    (interactive)
    (let* ((results (org-ref-get-bibtex-key-and-file))
           (key (car results))
           (pdf-file (funcall org-ref-get-pdf-filename-function key)))
      (with-current-buffer (find-file-noselect (cdr results))
        (save-excursion
          (bibtex-search-entry (car results))
          (org-ref-open-bibtex-pdf))))))
#+end_src
***** cdlatex
It's also nice to be able to use ~cdlatex~.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

It's handy to be able to quickly insert environments with =C-c }=. I almost always
want to edit them afterwards though, so let's make that happen by default.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src

At some point in the future it could be good to investigate [[https://scripter.co/splitting-an-org-block-into-two/][splitting org blocks]].
Likewise [[https://archive.casouri.cat/note/2020/insert-math-symbol-in-emacs/][this]] looks good for symbols.
***** Spellcheck
My spelling is atrocious, so let's get flycheck going.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-flyspell)
#+end_src
***** LSP support in ~src~ blocks
Now, by default, LSPs don't really function at all in ~src~ blocks.
#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang stringp)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))
(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh"))
(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))
#+end_src
***** View exported file
='localeader v= has no pre-existing binding, so I may as well use it with the same
functionality as in LaTeX. Let's try viewing possible output files with this.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src
**** Super agenda
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :commands (org-super-agenda-mode))
(after! org-agenda
  (org-super-agenda-mode))

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-compact-blocks t
      org-agenda-use-time-grid t
      org-agenda-time-grid '((require-timed remove-match) () " " "----------")
      org-agenda-time-leading-zero t
      org-agenda-start-day "0d"
      ;; don't see scheduled tasks until the scheduled data
      org-agenda-todo-ignore-scheduled 'future
      org-agenda-tags-todo-honor-ignore-options t
      org-agenda-tags-column 100
      org-deadline-warning-days 7
      org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")

(setq org-agenda-files '("~/doc/org"))

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-agenda-scheduled-leaders '("" ""))
                      (org-agenda-deadline-leaders '("D:" "D:" "D:"))
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)
                         (:name "Hidden Stuff Not Today"
                          :discard (:anything t))))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-agenda-sorting-strategy '(priority-down timestamp-up))
                       (org-super-agenda-groups
                        '((:discard (:tag ("read" "watch" "listen" "think")))
                          (:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :order 15)
                          (:name "Waiting"
                           :todo "WAITING"
                           :order 20)
                          (:name "University"
                           :tag "uni"
                           :order 32)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                            (:discard (:tag ("Chore" "Routine" "Daily")))))))))
          ("i" "Interesting"
           ((alltodo "" ((org-agenda-sorting-strategy '(priority-down timestamp-up))
                         (org-super-agenda-groups
                          '((:discard (:not (:tag ("read" "watch" "listen" "think"))))
                            (:name "Webpages"
                             :and (:tag ("read") :tag ("web"))
                             :order 1)
                            (:name "Info/Ideas"
                             :and (:tag ("read") :tag ("info"))
                             :tag "think"
                             :order 2)
                            (:name "Papers"
                             :and (:tag ("read") :tag ("research"))
                             :order 10)
                            (:name "Films"
                             :and (:tag ("watch") :tag ("film"))
                             :order 3)
                            (:name "Shows"
                             :and (:tag ("watch") :tag ("tv"))
                             :order 4)
                            (:name "Books"
                             :and (:tag ("read") :tag ("book"))
                             :order 5)
                            (:name "Audio"
                             :tag ("listen")
                             :order 6)))))))))
#+end_src
**** Capture
Let's setup some org-capture templates, and make them visually nice to access.

#+attr_html: :class invertible :alt My org-capture dialouge.
[[https://tecosaur.com/lfs/emacs-config/screenshots/org-capture.png]]

#+begin_src emacs-lisp :noweb no-export
(use-package! doct
  :commands (doct))

;; Workaround for wrong type argument: stringp, nil on org-capture
;; https://github.com/hlissner/doom-emacs/issues/4832
(advice-add #'org-capture :around
                 (lambda (fun &rest args)
                   (letf! ((#'+org--restart-mode-h #'ignore))
                     (apply fun args))))

(after! org-capture
  <<prettify-capture>>

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates (mapcar (lambda (template)
                                     (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                 (spec (plist-get (plist-get props :doct) :icon)))
                                       (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                      "\t"
                                                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))
  (defun set-org-capture-templates ()
    (setq org-capture-templates
          (doct `(("Personal todo" :keys "t"
                   :icon ("checklist" :set "octicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %? %^G")
                   )
                  ("Email" :keys "e"
                   :icon ("envelope" :set "faicon" :color "blue")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                              "Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}"
                              "about %^{topic} %U %i %a"))
                  ("Interesting" :keys "i"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Interesting"
                   :type entry
                   :template ("* TODO %{desc}%? :%{i-type}:"
                              "%i %a")
                   :children (("Webpage" :keys "w"
                               :icon ("globe" :set "faicon" :color "green")
                               :desc "%(org-cliplink-capture) "
                               :i-type "read:web"
                               )
                              ("Paper" :keys "p"
                               :icon ("file-text" :set "octicon" :color "yellow")
                               :desc ""
                               :i-type "read:research"
                               )
                              ("Book" :keys "b"
                               :icon ("file-text" :set "octicon" :color "white")
                               :desc ""
                               :i-type "read:book"
                               )
                              ("Film" :keys "f"
                               :icon ("film" :set "faicon" :color "magenta")
                               :desc ""
                               :i-type  "watch:film"
                                )
                              ("Shows" :keys "s"
                               :icon ("television" :set "faicon" :color "magenta")
                               :desc ""
                               :i-type  "watch:tv"
                                )
                              ("Audio" :keys "a"
                               :icon ("headphones" :set "faicon" :color "red")
                               :desc ""
                               :i-type  "listen"
                                )
                              ("Information" :keys "i"
                               :icon ("info-circle" :set "faicon" :color "blue")
                               :desc ""
                               :i-type "read:info"
                               )
                              ("Thought" :keys "t"
                               :icon ("bubble_chart" :set "material" :color "silver")
                               :desc ""
                               :i-type "think"
                               )))
                  ("Project" :keys "p"
                   :icon ("repo" :set "octicon" :color "silver")
                   :prepend t
                   :type entry
                   :headline "Inbox"
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :file ""
                   :custom (:time-or-todo "")
                   :children (("Project-local todo" :keys "t"
                               :icon ("checklist" :set "octicon" :color "green")
                               :time-or-todo "TODO"
                               :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                               :icon ("sticky-note" :set "faicon" :color "yellow")
                               :time-or-todo "%U"
                               :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                               :icon ("list" :set "faicon" :color "blue")
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-project-changelog-file))
                   )
                  ("\tCentralised project templates"
                   :keys "o"
                   :type entry
                   :prepend t
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :children (("Project todo"
                               :keys "t"
                               :prepend nil
                               :time-or-todo "TODO"
                               :heading "Tasks"
                               :file +org-capture-central-project-todo-file)
                              ("Project note"
                               :keys "n"
                               :time-or-todo "%U"
                               :heading "Notes"
                               :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                               :keys "c"
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-central-project-changelog-file))
                   )))))

  (set-org-capture-templates)
  (unless (display-graphic-p)
    (add-hook 'server-after-make-frame-hook
              (defun org-capture-reinitialise-hook ()
                (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                               #'org-capture-reinitialise-hook))))))
#+end_src
It would also be nice to improve how the capture dialogue looks
#+name: prettify-capture
#+begin_src emacs-lisp :tangle no
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"…

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "›" 'face 'font-lock-comment-face) "  " desc "…" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "─────────────────────────\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
(advice-add 'org-mks :override #'org-mks-pretty)
#+end_src
The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but I'd be nicer with a smaller frame, and
no modeline.
#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) "❖ Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src
**** Roam
#+begin_src emacs-lisp
(setq org-roam-directory (file-truename "~/doc/roam-org"))
(setq org-roam-dailies-directory (file-truename "~/doc/roam-org/daily"))
#+end_src

**** Nicer generated heading IDs
Thanks to alphapapa's [[https://github.com/alphapapa/unpackaged.el#export-to-html-with-useful-anchors][unpackaged.el]].

By default, ~url-hexify-string~ seemed to cause me some issues. Replacing that in
~a53899~ resolved this for me. To go one step further, I create a function for
producing nice short links, like an inferior version of ~reftex-label~.

#+begin_src emacs-lisp
(defvar org-reference-contraction-max-words 3
  "Maximum number of words in a reference reference.")
(defvar org-reference-contraction-max-length 35
  "Maximum length of resulting reference reference, including joining characters.")
(defvar org-reference-contraction-stripped-words
  '("the" "on" "in" "off" "a" "for" "by" "of" "and" "is" "to")
  "Superfluous words to be removed from a reference.")
(defvar org-reference-contraction-joining-char "-"
  "Character used to join words in the reference reference.")

(defun org-reference-contraction-truncate-words (words)
  "Using `org-reference-contraction-max-length' as the total character 'budget' for the WORDS
and truncate individual words to conform to this budget.

To arrive at a budget that accounts for words undershooting their requisite average length,
the number of characters in the budget freed by short words is distributed among the words
exceeding the average length.  This adjusts the per-word budget to be the maximum feasable for
this particular situation, rather than the universal maximum average.

This budget-adjusted per-word maximum length is given by the mathematical expression below:

max length = \\floor{ \\frac{total length - chars for seperators - \\sum_{word \\leq average length} length(word) }{num(words) > average length} }"
  ;; trucate each word to a max word length determined by
  ;;
  (let* ((total-length-budget (- org-reference-contraction-max-length  ; how many non-separator chars we can use
                                 (1- (length words))))
         (word-length-budget (/ total-length-budget                      ; max length of each word to keep within budget
                                org-reference-contraction-max-words))
         (num-overlong (-count (lambda (word)                            ; how many words exceed that budget
                                 (> (length word) word-length-budget))
                               words))
         (total-short-length (-sum (mapcar (lambda (word)                ; total length of words under that budget
                                             (if (<= (length word) word-length-budget)
                                                 (length word) 0))
                                           words)))
         (max-length (/ (- total-length-budget total-short-length)       ; max(max-length) that we can have to fit within the budget
                        num-overlong)))
    (mapcar (lambda (word)
              (if (<= (length word) max-length)
                  word
                (substring word 0 max-length)))
            words)))

(defun org-reference-contraction (reference-string)
  "Give a contracted form of REFERENCE-STRING that is only contains alphanumeric characters.
Strips 'joining' words present in `org-reference-contraction-stripped-words',
and then limits the result to the first `org-reference-contraction-max-words' words.
If the total length is > `org-reference-contraction-max-length' then individual words are
truncated to fit within the limit using `org-reference-contraction-truncate-words'."
  (let ((reference-words
         (-filter (lambda (word)
                    (not (member word org-reference-contraction-stripped-words)))
                  (split-string
                   (->> reference-string
                     downcase
                     (replace-regexp-in-string "\\[\\[[^]]+\\]\\[\\([^]]+\\)\\]\\]" "\\1") ; get description from org-link
                     (replace-regexp-in-string "[-/ ]+" " ") ; replace seperator-type chars with space
                     (replace-regexp-in-string "[^a-z0-9 ]" "") ; strip chars which need %-encoding in a uri
                     ) " "))))
    (when (> (length reference-words)
             org-reference-contraction-max-words)
      (setq reference-words
            (cl-subseq reference-words 0 org-reference-contraction-max-words)))

    (when (> (apply #'+ (1- (length reference-words))
                    (mapcar #'length reference-words))
             org-reference-contraction-max-length)
      (setq reference-words (org-reference-contraction-truncate-words reference-words)))

    (string-join reference-words org-reference-contraction-joining-char)))
#+end_src
Now here's alphapapa's subtly tweaked mode.
#+begin_src emacs-lisp
(define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
  "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
  :global t
  (if unpackaged/org-export-html-with-useful-ids-mode
      (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
    (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))
(unpackaged/org-export-html-with-useful-ids-mode 1) ; ensure enabled, and advice run

(defun unpackaged/org-export-get-reference (datum info)
  "Like `org-export-get-reference', except uses heading titles instead of random numbers."
  (let ((cache (plist-get info :internal-references)))
    (or (car (rassq datum cache))
        (let* ((crossrefs (plist-get info :crossrefs))
               (cells (org-export-search-cells datum))
               ;; Preserve any pre-existing association between
               ;; a search cell and a reference, i.e., when some
               ;; previously published document referenced a location
               ;; within current file (see
               ;; `org-publish-resolve-external-link').
               ;;
               ;; However, there is no guarantee that search cells are
               ;; unique, e.g., there might be duplicate custom ID or
               ;; two headings with the same title in the file.
               ;;
               ;; As a consequence, before re-using any reference to
               ;; an element or object, we check that it doesn't refer
               ;; to a previous element or object.
               (new (or (cl-some
                         (lambda (cell)
                           (let ((stored (cdr (assoc cell crossrefs))))
                             (when stored
                               (let ((old (org-export-format-reference stored)))
                                 (and (not (assoc old cache)) stored)))))
                         cells)
                        (when (org-element-property :raw-value datum)
                          ;; Heading with a title
                          (unpackaged/org-export-new-named-reference datum cache))
                        (when (member (car datum) '(src-block table example fixed-width property-drawer))
                          ;; Nameable elements
                          (unpackaged/org-export-new-named-reference datum cache))
                        ;; NOTE: This probably breaks some Org Export
                        ;; feature, but if it does what I need, fine.
                        (org-export-format-reference
                         (org-export-new-reference cache))))
               (reference-string new))
          ;; Cache contains both data already associated to
          ;; a reference and in-use internal references, so as to make
          ;; unique references.
          (dolist (cell cells) (push (cons cell new) cache))
          ;; Retain a direct association between reference string and
          ;; DATUM since (1) not every object or element can be given
          ;; a search cell (2) it permits quick lookup.
          (push (cons reference-string datum) cache)
          (plist-put info :internal-references cache)
          reference-string))))

(defun unpackaged/org-export-new-named-reference (datum cache)
  "Return new reference for DATUM that is unique in CACHE."
  (cl-macrolet ((inc-suffixf (place)
                             `(progn
                                (string-match (rx bos
                                                  (minimal-match (group (1+ anything)))
                                                  (optional "--" (group (1+ digit)))
                                                  eos)
                                              ,place)
                                ;; HACK: `s1' instead of a gensym.
                                (-let* (((s1 suffix) (list (match-string 1 ,place)
                                                           (match-string 2 ,place)))
                                        (suffix (if suffix
                                                    (string-to-number suffix)
                                                  0)))
                                  (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
    (let* ((headline-p (eq (car datum) 'headline))
           (title (if headline-p
                      (org-element-property :raw-value datum)
                    (or (org-element-property :name datum)
                        (concat (org-element-property :raw-value
                                                      (org-element-property :parent
                                                                            (org-element-property :parent datum)))))))
           ;; get ascii-only form of title without needing percent-encoding
           (ref (concat (org-reference-contraction (substring-no-properties title))
                        (unless (or headline-p (org-element-property :name datum))
                          (concat ","
                                  (pcase (car datum)
                                    ('src-block "code")
                                    ('example "example")
                                    ('fixed-width "mono")
                                    ('property-drawer "properties")
                                    (_ (symbol-name (car datum))))
                                  "--1"))))
           (parent (when headline-p (org-element-property :parent datum))))
      (while (--any (equal ref (car it))
                    cache)
        ;; Title not unique: make it so.
        (if parent
            ;; Append ancestor title.
            (setf title (concat (org-element-property :raw-value parent)
                                "--" title)
                  ;; get ascii-only form of title without needing percent-encoding
                  ref (org-reference-contraction (substring-no-properties title))
                  parent (when headline-p (org-element-property :parent parent)))
          ;; No more ancestors: add and increment a number.
          (inc-suffixf ref)))
      ref)))

(add-hook 'org-load-hook #'unpackaged/org-export-html-with-useful-ids-mode)
#+end_src
**** Nicer ~org-return~
Once again, from [[https://github.com/alphapapa/unpackaged.el#org-return-dwim][unpackaged.el]]
#+begin_src emacs-lisp
(defun unpackaged/org-element-descendant-of (type element)
  "Return non-nil if ELEMENT is a descendant of TYPE.
TYPE should be an element type, like `item' or `paragraph'.
ELEMENT should be a list like that returned by `org-element-context'."
  ;; MAYBE: Use `org-element-lineage'.
  (when-let* ((parent (org-element-property :parent element)))
    (or (eq type (car parent))
        (unpackaged/org-element-descendant-of type parent))))

;;;###autoload
(defun unpackaged/org-return-dwim (&optional default)
  "A helpful replacement for `org-return-indent'.  With prefix, call `org-return-indent'.

On headings, move point to position after entry content.  In
lists, insert a new item or end the list, with checkbox if
appropriate.  In tables, insert a new row or end the table."
  ;; Inspired by John Kitchin: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/
  (interactive "P")
  (if default
      (org-return t)
    (cond
     ;; Act depending on context around point.

     ;; NOTE: I prefer RET to not follow links, but by uncommenting this block, links will be
     ;; followed.

     ;; ((eq 'link (car (org-element-context)))
     ;;  ;; Link: Open it.
     ;;  (org-open-at-point-global))

     ((org-at-heading-p)
      ;; Heading: Move to position after entry content.
      ;; NOTE: This is probably the most interesting feature of this function.
      (let ((heading-start (org-entry-beginning-position)))
        (goto-char (org-entry-end-position))
        (cond ((and (org-at-heading-p)
                    (= heading-start (org-entry-beginning-position)))
               ;; Entry ends on its heading; add newline after
               (end-of-line)
               (insert "\n\n"))
              (t
               ;; Entry ends after its heading; back up
               (forward-line -1)
               (end-of-line)
               (when (org-at-heading-p)
                 ;; At the same heading
                 (forward-line)
                 (insert "\n")
                 (forward-line -1))
               ;; FIXME: looking-back is supposed to be called with more arguments.
               (while (not (looking-back (rx (repeat 3 (seq (optional blank) "\n")))))
                 (insert "\n"))
               (forward-line -1)))))

     ((org-at-item-checkbox-p)
      ;; Checkbox: Insert new item with checkbox.
      (org-insert-todo-heading nil))

     ((org-in-item-p)
      ;; Plain list.  Yes, this gets a little complicated...
      (let ((context (org-element-context)))
        (if (or (eq 'plain-list (car context))  ; First item in list
                (and (eq 'item (car context))
                     (not (eq (org-element-property :contents-begin context)
                              (org-element-property :contents-end context))))
                (unpackaged/org-element-descendant-of 'item context))  ; Element in list item, e.g. a link
            ;; Non-empty item: Add new item.
            (org-insert-item)
          ;; Empty item: Close the list.
          ;; TODO: Do this with org functions rather than operating on the text. Can't seem to find the right function.
          (delete-region (line-beginning-position) (line-end-position))
          (insert "\n"))))

     ((when (fboundp 'org-inlinetask-in-task-p)
        (org-inlinetask-in-task-p))
      ;; Inline task: Don't insert a new heading.
      (org-return t))

     ((org-at-table-p)
      (cond ((save-excursion
               (beginning-of-line)
               ;; See `org-table-next-field'.
               (cl-loop with end = (line-end-position)
                        for cell = (org-element-table-cell-parser)
                        always (equal (org-element-property :contents-begin cell)
                                      (org-element-property :contents-end cell))
                        while (re-search-forward "|" end t)))
             ;; Empty row: end the table.
             (delete-region (line-beginning-position) (line-end-position))
             (org-return t))
            (t
             ;; Non-empty row: call `org-return-indent'.
             (org-return t))))
     (t
      ;; All other cases: call `org-return-indent'.
      (org-return t)))))

(map!
 :after evil-org
 :map evil-org-mode-map
 :i [return] #'unpackaged/org-return-dwim)
#+end_src
**** Snippet Helpers

I often want to set =src-block= headers, and it's a pain to
+ type them out
+ remember what the accepted values are
+ oh, and specifying the same language again and again

We can solve this in three steps
+ having one-letter snippets, conditioned on ~(point)~ being within a src header
+ creating a nice prompt showing accepted values and the current default
+ pre-filling the =src-block= language with the last language used

For header args, the keys I'll use are
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

Now let's write a function we can reference in yasnippets to produce a nice
interactive way to specify header args.

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read question values :preselect default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

**** Translate capital keywords (old) to lower case (new)
Everyone used to use ~#+CAPITAL~ keywords. Then people realised that ~#+lowercase~
is actually both marginally easier and visually nicer, so now the capital
version is just used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote

To avoid sometimes having to choose between the hassle out of updating old
documents and using mixed syntax, I'll whip up a basic transcode-y function.
It likely misses some edge cases, but should mostly work.

#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src
**** Extra links
***** YouTube
The ~[[yt:...]]~ links preview nicely, but don't export nicely. Thankfully, we can
fix that.
#+begin_src emacs-lisp
(org-link-set-parameters "yt" :export #'+org-export-yt)
(defun +org-export-yt (path desc backend _com)
  (cond ((org-export-derived-backend-p backend 'html)
         (format "<iframe width='440' \
height='335' \
src='https://www.youtube.com/embed/%s' \
frameborder='0' \
allowfullscreen>%s</iframe>" path (or "" desc)))
        ((org-export-derived-backend-p backend 'latex)
         (format "\\href{https://youtu.be/%s}{%s}" path (or desc "youtube")))
        (t (format "https://youtu.be/%s" path))))
#+end_src
**** Fix problematic hooks
When one of the src_elisp{org-mode-hook} functions errors, it halts the hook
execution. This is problematic, and there are two hooks in particular which
cause issues. Let's make their failure less eventful.

#+begin_src emacs-lisp :tangle no
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  (ignore-errors (apply orig-fn args)))
#+end_src
*** Visuals

Here I try to do two things: improve the styling of the various documents, via
font changes etc, and also propagate colours from the current theme.

**** Font Display
Mixed pitch is great. As is ~+org-pretty-mode~, let's use them.
#+begin_src emacs-lisp
(add-hook! 'org-mode-hook #'+org-pretty-mode #'mixed-pitch-mode)
#+end_src

Let's make headings a bit bigger
#+begin_src emacs-lisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

And the same with the title.
#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

It seems reasonable to have deadlines in the error face when they're passed.
#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

We can then have quote blocks stand out a bit more by making them /italic/.
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.
#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

Org files can be rather nice to look at, particularly with some of the
customisations here. This comes at a cost however, expensive font-lock.
Feeling like you're typing through molasses in large files is no fun, but there
is a way I can defer font-locking when typing to make the experience more
responsive.
#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src
Apparently this causes issues with some people, but I haven't noticed anything
problematic beyond the expected slight delay in some fontification, so until I
do I'll use the above.

**** Fontifying inline src blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for
language's major-mode behind the scenes and pulling out the lovely colourful
results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to
stackexchange]] to voice their desire for inline src fontification. I was going to
steal their work, but unfortunately they didn't perform /true/ source code
fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~
we can apply language-appropriate syntax highlighting. Then, continuing on to
={{{results(...)}}}= , it can have the =org-block= face applied to match, and then
the value-surrounding constructs hidden by mimicking the behaviour of
~prettify-symbols-mode~.

#+begin_warning
This currently only highlights a single inline src block per line.
I have no idea why it stops, but I'd rather it didn't.
If you have any idea what's going on or how to fix this /please/ get in touch.
#+end_warning

#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟨" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟩" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src

**** LaTeX Fragments
***** Prettier highlighting
First off, we want those fragments to look good.
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

However, by using =native= highlighting the =org-block= face is added, and that
doesn't look too great --- particularly when the fragments are previewed.

Ideally ~org-src-font-lock-fontify-block~ wouldn't add the =org-block= face, but we
can avoid advising that entire function by just adding another face with
=:inherit default= which will override the background colour.

Inspecting ~org-do-latex-and-related~ shows that ="latex"= is the language argument
passed, and so we can override the background as discussed above.
#+begin_src emacs-lisp
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

***** More eager rendering
What's better than syntax-highlighted LaTeX is /rendered/ LaTeX though, and we can
have this be performed automatically with =org-fragtog=.
#+begin_src emacs-lisp
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

***** Prettier rendering
It's nice to customise the look of LaTeX fragments so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).
Let's start by adding a sans font. I'd also like to use some of the
functionality from =bmc-maths=, so we'll load that too.

#+begin_src emacs-lisp
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{xcolor}

\\usepackage[T1]{fontenc}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage[nofont,plaindd]{bmc-maths}
\\usepackage{arev}
")
#+end_src

Since we can, instead of making the background colour match the =default= face,
let's make it transparent.
#+begin_src emacs-lisp
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src

***** Rendering speed tests
We can either render from a ~dvi~ or ~pdf~ file, so let's benchmark ~latex~ and
~pdflatex~.
| ~latex~ time | ~pdflatex~ time |
|------------+---------------|
| 135 \pm 2 ms | 215 \pm 3 ms    |

On the rendering side, there are two ~.dvi~-to-image converters which I am
interested in: ~dvipng~ and ~dvisvgm~. Then with the a ~.pdf~ we have ~pdf2svg~.
For inline preview we care about speed, while for exporting we care about file
size and prefer a vector graphic.

Using the above latex expression and benchmarking lead to the following results:
| ~dvipng~ time | ~dvisvgm~ time | ~pdf2svg~ time |
|-------------+--------------+--------------|
| 89 \pm 2 ms   | 178 \pm 2 ms   | 12 \pm 2 ms    |

Now let's combine this to see what's best
| Tool chain         | Total time | Resultant file size |
|--------------------+------------+---------------------|
| ~latex~ + ~dvipng~     | 226 \pm 2 ms | 7 KiB               |
| ~latex~ + ~dvisvgm~    | 392 \pm 4 ms | 8 KiB               |
| ~pdflatex~ + ~pdf2svg~ | 230 \pm 2 ms | 16 KiB              |

So, let's use ~dvipng~ for previewing LaTeX fragments in-Emacs, but ~dvisvgm~ for [[LaTeX Rendering]].

#+begin_warning
Unfortunately, it seems that SVG sizing is annoying ATM, so let's actually not do this right now.
#+end_warning

**** Stolen from [[https://github.com/jkitchin/scimax][scimax]] (semi-working right now)
I want fragment justification
#+begin_src emacs-lisp
(defun scimax-org-latex-fragment-justify (justification)
  "Justify the latex fragment at point with JUSTIFICATION.
JUSTIFICATION is a symbol for 'left, 'center or 'right."
  (interactive
   (list (intern-soft
          (completing-read "Justification (left): " '(left center right)
                           nil t nil nil 'left))))
  (let* ((ov (ov-at))
         (beg (ov-beg ov))
         (end (ov-end ov))
         (shift (- beg (line-beginning-position)))
         (img (overlay-get ov 'display))
         (img (and (and img (consp img) (eq (car img) 'image)
                        (image-type-available-p (plist-get (cdr img) :type)))
                   img))
         space-left offset)
    (when (and img
               ;; This means the equation is at the start of the line
               (= beg (line-beginning-position))
               (or
                (string= "" (s-trim (buffer-substring end (line-end-position))))
                (eq 'latex-environment (car (org-element-context)))))
      (setq space-left (- (window-max-chars-per-line) (car (image-size img)))
            offset (floor (cond
                           ((eq justification 'center)
                            (- (/ space-left 2) shift))
                           ((eq justification 'right)
                            (- space-left shift))
                           (t
                            0))))
      (when (>= offset 0)
        (overlay-put ov 'before-string (make-string offset ?\ ))))))

(defun scimax-org-latex-fragment-justify-advice (beg end image imagetype)
  "After advice function to justify fragments."
  (scimax-org-latex-fragment-justify (or (plist-get org-format-latex-options :justify) 'left)))


(defun scimax-toggle-latex-fragment-justification ()
  "Toggle if LaTeX fragment justification options can be used."
  (interactive)
  (if (not (get 'scimax-org-latex-fragment-justify-advice 'enabled))
      (progn
        (advice-add 'org--format-latex-make-overlay :after 'scimax-org-latex-fragment-justify-advice)
        (put 'scimax-org-latex-fragment-justify-advice 'enabled t)
        (message "Latex fragment justification enabled"))
    (advice-remove 'org--format-latex-make-overlay 'scimax-org-latex-fragment-justify-advice)
    (put 'scimax-org-latex-fragment-justify-advice 'enabled nil)
    (message "Latex fragment justification disabled")))
#+end_src
There's also this lovely equation numbering stuff I'll nick
#+begin_src emacs-lisp
;; Numbered equations all have (1) as the number for fragments with vanilla
;; org-mode. This code injects the correct numbers into the previews so they
;; look good.
(defun scimax-org-renumber-environment (orig-func &rest args)
  "A function to inject numbers in LaTeX fragment previews."
  (let ((results '())
        (counter -1)
        (numberp))
    (setq results (cl-loop for (begin . env) in
                           (org-element-map (org-element-parse-buffer) 'latex-environment
                             (lambda (env)
                               (cons
                                (org-element-property :begin env)
                                (org-element-property :value env))))
                           collect
                           (cond
                            ((and (string-match "\\\\begin{equation}" env)
                                  (not (string-match "\\\\tag{" env)))
                             (cl-incf counter)
                             (cons begin counter))
                            ((string-match "\\\\begin{align}" env)
                             (prog2
                                 (cl-incf counter)
                                 (cons begin counter)
                               (with-temp-buffer
                                 (insert env)
                                 (goto-char (point-min))
                                 ;; \\ is used for a new line. Each one leads to a number
                                 (cl-incf counter (count-matches "\\\\$"))
                                 ;; unless there are nonumbers.
                                 (goto-char (point-min))
                                 (cl-decf counter (count-matches "\\nonumber")))))
                            (t
                             (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))

  (apply orig-func args))


(defun scimax-toggle-latex-equation-numbering ()
  "Toggle whether LaTeX fragments are numbered."
  (interactive)
  (if (not (get 'scimax-org-renumber-environment 'enabled))
      (progn
        (advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
        (put 'scimax-org-renumber-environment 'enabled t)
        (message "Latex numbering enabled"))
    (advice-remove 'org-create-formula-image #'scimax-org-renumber-environment)
    (put 'scimax-org-renumber-environment 'enabled nil)
    (message "Latex numbering disabled.")))

(advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
(put 'scimax-org-renumber-environment 'enabled t)
#+end_src
**** Org Plot
We can use some of the variables in =org-plot= to use the current doom theme
colours.
#+begin_src emacs-lisp
(after! org-plot
  (defun org-plot/generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ))
  (defun org-plot/gnuplot-term-properties (_type)
    (format "background rgb '%s' size 1050,650"
            (doom-color 'bg)))
  (setq org-plot/gnuplot-script-preamble #'org-plot/generate-theme)
  (setq org-plot/gnuplot-term-extra #'org-plot/gnuplot-term-properties))
#+end_src
*** Exporting
**** General settings
#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src
I'm also going to make use of an item in =ox-extra= so that I can add an =:ignore:=
tag to headings for the content to be kept, but the heading itself ignored
(unlike =:noexport:= which ignored both heading and content). This is useful when
I want to use headings to provide a structure for writing that doesn't appear in
the final documents.
#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

**** Accept verbatim text in headings

LaTeX doesn't like it when =\verb= is used inside the argument of other commands
apparently. This means that when it's used in a =\section= command (or similar)
compilation fails. This is rather disappointing. So, let's change any instances
to use =\texttt=. We'll actually hook this in the [[*Acronym formatting][Acronym formatting]] section, so
we'll just define a function to perform this transformation for now.

#+begin_src emacs-lisp
(defun org-latex-substitute-verb-with-texttt (content)
  "Replace instances of \\verb with \\texttt{}."
  (replace-regexp-in-string
   "\\\\verb\\(.\\).+?\\1"
   (lambda (verb-string)
     (replace-regexp-in-string
      "\\\\" "\\\\\\\\" ; Why elisp, why?
      (org-latex--text-markup (substring verb-string 6 -1) 'code '(:latex-text-markup-alist ((code . protectedtexttt))))))
   content))
#+end_src

**** Acronym formatting
I like automatically using spaced small caps for acronyms. For strings I want to
be unaffected let's use ~;~ as a prefix to prevent the transformation --- i.e.
~;JFK~ (as one would want for two-letter geographic locations and names).

This has to be implemented on a per-format basis, currently HTML and LaTeX
exports are supported.

#+begin_src emacs-lisp
(defun org-export-filter-text-acronym (text backend _info)
  "Wrap suspected acronyms in acronyms-specific formatting.
Treat sequences of 2+ capital letters (optionally succeeded by \"s\") as an acronym.
Ignore if preceeded by \";\" (for manual prevention) or \"\\\" (for LaTeX commands).

TODO abstract backend implementations."
  (let ((base-backend
         (cond
          ((org-export-derived-backend-p backend 'latex) 'latex)
          ;; Markdown is derived from HTML, but we don't want to format it
          ((org-export-derived-backend-p backend 'md) nil)
          ((org-export-derived-backend-p backend 'html) 'html)))
        (case-fold-search nil))
    (when base-backend
      (replace-regexp-in-string
       "[;\\\\]?\\b[A-Z][A-Z]+s?\\(?:[^A-Za-z]\\|\\b\\)"
       (lambda (all-caps-str)
         (cond ((equal (aref all-caps-str 0) ?\\) all-caps-str)                ; don't format LaTeX commands
               ((equal (aref all-caps-str 0) ?\;) (substring all-caps-str 1))  ; just remove not-acronym indicator char ";"
               (t (let* ((final-char (if (string-match-p "[^A-Za-z]" (substring all-caps-str -1 (length all-caps-str)))
                                         (substring all-caps-str -1 (length all-caps-str))
                                       nil)) ; needed to re-insert the [^A-Za-z] at the end
                         (trailing-s (equal (aref all-caps-str (- (length all-caps-str) (if final-char 2 1))) ?s))
                         (acr (if final-char
                                  (substring all-caps-str 0 (if trailing-s -2 -1))
                                (substring all-caps-str 0 (+ (if trailing-s -1 (length all-caps-str)))))))
                    (pcase base-backend
                      ('latex (concat "\\acr{" (s-downcase acr) "}" (when trailing-s "\\acrs{}") final-char))
                      ('html (concat "<span class='acr'>" acr "</span>" (when trailing-s "<small>s</small>") final-char)))))))
       text t t))))

(add-to-list 'org-export-filter-plain-text-functions
             #'org-export-filter-text-acronym)

;; We won't use `org-export-filter-headline-functions' because it
;; passes (and formats) the entire section contents. That's no good.

(defun org-html-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-html-format-headline-default-function', but with acronym formatting."
  (org-html-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'html info) tags info))
(setq org-html-format-headline-function #'org-html-format-headline-acronymised)

(defun org-latex-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-latex-format-headline-default-function', but with acronym formatting."
  (org-latex-format-headline-default-function
   todo todo-type priority (org-latex-substitute-verb-with-texttt
                            (org-export-filter-text-acronym text 'latex info)) tags info))
(setq org-latex-format-headline-function #'org-latex-format-headline-acronymised)
#+end_src

*** HTML Export
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref ox-html-conf
:END:
I want to tweak a whole bunch of things. While I'll want my tweaks almost all
the time, occasionally I may want to test how something turns out using a more
default config. With that in mind, a global minor mode seems like the most
appropriate architecture to use.
#+begin_src emacs-lisp
(define-minor-mode org-fancy-html-export-mode
  "Toggle my fabulous org export tweaks. While this mode itself does a little bit,
the vast majority of the change in behaviour comes from switch statements in:
 - `org-html-template-fancier'
 - `org-html--build-meta-info-extended'
 - `org-html-src-block-collapsable'
 - `org-html-block-collapsable'
 - `org-html-table-wrapped'
 - `org-html--format-toc-headline-colapseable'
 - `org-html--toc-text-stripped-leaves'
 - `org-export-html-headline-anchor'"
  :global t
  :init-value t
  (if org-fancy-html-export-mode
      (setq org-html-style-default org-html-style-fancy
            org-html-meta-tags #'org-html-meta-tags-fancy
            org-html-checkbox-type 'html-span)
    (setq org-html-style-default org-html-style-plain
          org-html-meta-tags #'org-html-meta-tags-default
          org-html-checkbox-type 'html)))
#+end_src

There are quite a few instances where I want to modify variables defined in
=ox-html=, so we'll wrap the contents of this section in a
src_elisp{(after! ox-html ...)} block.
#+begin_src emacs-lisp :noweb no-export :noweb-ref org-conf
(after! ox-html
  <<ox-html-conf>>
  )
#+end_src
**** Extra header content
We want to tack on a few more bits to the start of the body. Unfortunately, there
doesn't seem to be any nice variable or hook, so we'll just override the
relevant function.

This is done to allow me to add the date and author to the page header,
implement a CSS-only light/dark theme toggle, and a sprinkle of [[https://ogp.me/][Open Graph]]
metadata.
#+begin_src emacs-lisp
(defadvice! org-html-template-fancier (orig-fn contents info)
  "Return complete document string after HTML conversion.
CONTENTS is the transcoded contents string.  INFO is a plist
holding export options. Adds a few extra things to the body
compared to the default implementation."
  :around #'org-html-template
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn contents info)
    (concat
     (when (and (not (org-html-html5-p info)) (org-html-xhtml-p info))
       (let* ((xml-declaration (plist-get info :html-xml-declaration))
              (decl (or (and (stringp xml-declaration) xml-declaration)
                        (cdr (assoc (plist-get info :html-extension)
                                    xml-declaration))
                        (cdr (assoc "html" xml-declaration))
                        "")))
         (when (not (or (not decl) (string= "" decl)))
           (format "%s\n"
                   (format decl
                           (or (and org-html-coding-system
                                    (fboundp 'coding-system-get)
                                    (coding-system-get org-html-coding-system 'mime-charset))
                               "iso-8859-1"))))))
     (org-html-doctype info)
     "\n"
     (concat "<html"
             (cond ((org-html-xhtml-p info)
                    (format
                     " xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"%s\" xml:lang=\"%s\""
                     (plist-get info :language) (plist-get info :language)))
                   ((org-html-html5-p info)
                    (format " lang=\"%s\"" (plist-get info :language))))
             ">\n")
     "<head>\n"
     (org-html--build-meta-info info)
     (org-html--build-head info)
     (org-html--build-mathjax-config info)
     "</head>\n"
     "<body>\n<input type='checkbox' id='theme-switch'><div id='page'><label id='switch-label' for='theme-switch'></label>"
     (let ((link-up (org-trim (plist-get info :html-link-up)))
           (link-home (org-trim (plist-get info :html-link-home))))
       (unless (and (string= link-up "") (string= link-home ""))
         (format (plist-get info :html-home/up-format)
                 (or link-up link-home)
                 (or link-home link-up))))
     ;; Preamble.
     (org-html--build-pre/postamble 'preamble info)
     ;; Document contents.
     (let ((div (assq 'content (plist-get info :html-divs))))
       (format "<%s id=\"%s\">\n" (nth 1 div) (nth 2 div)))
     ;; Document title.
     (when (plist-get info :with-title)
       (let ((title (and (plist-get info :with-title)
                         (plist-get info :title)))
             (subtitle (plist-get info :subtitle))
             (html5-fancy (org-html--html5-fancy-p info)))
         (when title
           (format
            "<div class='page-header'><div class='page-meta'>%s, %s</div><h1 class=\"title\">%s%s</h1></div>\n"
            (org-export-data (plist-get info :date) info)
            (org-export-data (plist-get info :author) info)
            (org-export-data title info)
            (if subtitle
                (format
                 (if html5-fancy
                     "<p class=\"subtitle\">%s</p>\n"
                   (concat "\n" (org-html-close-tag "br" nil info) "\n"
                           "<span class=\"subtitle\">%s</span>\n"))
                 (org-export-data subtitle info))
              "")))))
     contents
     (format "</%s>\n" (nth 1 (assq 'content (plist-get info :html-divs))))
     ;; Postamble.
     (org-html--build-pre/postamble 'postamble info)
     ;; Possibly use the Klipse library live code blocks.
     (when (plist-get info :html-klipsify-src)
       (concat "<script>" (plist-get info :html-klipse-selection-script)
               "</script><script src=\""
               org-html-klipse-js
               "\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\""
               org-html-klipse-css "\"/>"))
     ;; Closing document.
     "</div>\n</body>\n</html>")))
#+end_src

I think it would be nice if "Table of Contents" brought you back to the top of
the page. Well, since we've done this much advising already...
#+begin_src emacs-lisp
(defadvice! org-html-toc-linked (depth info &optional scope)
  "Build a table of contents.

Just like `org-html-toc', except the header is a link to \"#\".

DEPTH is an integer specifying the depth of the table.  INFO is
a plist used as a communication channel.  Optional argument SCOPE
is an element defining the scope of the table.  Return the table
of contents as a string, or nil if it is empty."
  :override #'org-html-toc
  (let ((toc-entries
         (mapcar (lambda (headline)
                   (cons (org-html--format-toc-headline headline info)
                         (org-export-get-relative-level headline info)))
                 (org-export-collect-headlines info depth scope))))
    (when toc-entries
      (let ((toc (concat "<div id=\"text-table-of-contents\">"
                         (org-html--toc-text toc-entries)
                         "</div>\n")))
        (if scope toc
          (let ((outer-tag (if (org-html--html5-fancy-p info)
                               "nav"
                             "div")))
            (concat (format "<%s id=\"table-of-contents\">\n" outer-tag)
                    (let ((top-level (plist-get info :html-toplevel-hlevel)))
                      (format "<h%d><a href=\"#\" style=\"color:inherit; text-decoration: none;\">%s</a></h%d>\n"
                              top-level
                              (org-html--translate "Table of Contents" info)
                              top-level))
                    toc
                    (format "</%s>\n" outer-tag))))))))
#+end_src

Lastly, let's pile on some metadata. This gives my pages nice embeds.
#+begin_src emacs-lisp
(defun org-html-meta-tags-fancy (info)
  "Use the INFO plist to construct the meta tags, as described in `org-html-meta-tags'."
  (let ((title (org-html-plain-text
                (org-element-interpret-data (plist-get info :title)) info))
        (author (and (plist-get info :with-author)
                     (let ((auth (plist-get info :author)))
                       ;; Return raw Org syntax.
                       (and auth (org-html-plain-text
                                  (org-element-interpret-data auth) info))))))
    (list
     (when (org-string-nw-p author)
       (list "name" "author" author))
     (when (org-string-nw-p (plist-get info :description))
       (list "name" "description"
             (plist-get info :description)))
     '("name" "generator" "org mode")
     '("name" "theme-color" "#77aa99")
     '("property" "og:type" "article")
     (list "property" "og:title" title)
     (let ((subtitle (org-export-data (plist-get info :subtitle) info)))
       (when (org-string-nw-p subtitle)
         (list "property" "og:description" subtitle)))
     '("property" "og:image" "https://tecosaur.com/resources/org/nib.png")
     '("property" "og:image:type" "image/png")
     '("property" "og:image:width" "200")
     '("property" "og:image:height" "200")
     '("property" "og:image:alt" "Green fountain pen nib")
     (when (org-string-nw-p author)
       (list "property" "og:article:author:first_name" (car (s-split-up-to " " author 2))))
     (when (and (org-string-nw-p author) (s-contains-p " " author))
       (list "property" "og:article:author:last_name" (cadr (s-split-up-to " " author 2))))
     (list "property" "og:article:published_time" (format-time-string "%FT%T%z")))))

(unless (functionp #'org-html-meta-tags-default)
  (defalias 'org-html-meta-tags-default #'ignore))
(setq org-html-meta-tags #'org-html-meta-tags-fancy)
#+end_src
**** Custom CSS/JS
The default org HTML export is ... alright, but we can really jazz it up.
[[https://lepisma.xyz][lepisma.xyz]] has a really nice style, and from and org export too!
Suffice to say I've snatched it, with a few of my own tweaks applied.

#+begin_src html :tangle misc/org-export-header.html :comments no
<link rel="icon" href="https://tecosaur.com/resources/org/nib.ico" type="image/ico" />

<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-roman-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-italic-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextRegular.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextItalic.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextBold.woff2">
#+end_src

#+begin_src emacs-lisp
(setq org-html-style-plain org-html-style-default
      org-html-htmlize-output-type 'css
      org-html-doctype "html5"
      org-html-html5-fancy t)

(defun org-html-reload-fancy-style ()
  (interactive)
  (setq org-html-style-fancy
        (concat (f-read-text (expand-file-name "misc/org-export-header.html" doom-private-dir))
                "<script>\n"
                (f-read-text (expand-file-name "misc/org-css/main.js" doom-private-dir))
                "</script>\n<style>\n"
                (f-read-text (expand-file-name "misc/org-css/main.min.css" doom-private-dir))
                "</style>"))
  (when org-fancy-html-export-mode
    (setq org-html-style-default org-html-style-fancy)))
(org-html-reload-fancy-style)
#+end_src
**** Collapsable src and example blocks
By wrapping the ~<pre>~ element in a ~<details>~ block, we can obtain collapsable
blocks with no CSS, though we will toss a little in anyway to have this looking
somewhat spiffy.

Since this collapsability seems useful to have on by default for certain chunks
of code, it would be nice if you could set it with =#+attr_html: :collapsed t=.

It would be nice to also have a corresponding global / session-local way of
setting this, but I haven't quite been able to get that working (yet).

#+begin_src emacs-lisp
(defvar org-html-export-collapsed nil)
(eval '(cl-pushnew '(:collapsed "COLLAPSED" "collapsed" org-html-export-collapsed t)
                   (org-export-backend-options (org-export-get-backend 'html))))
(add-to-list 'org-default-properties "EXPORT_COLLAPSED")
#+end_src

We can take our src block modification a step further, and add a gutter on the
side of the src block containing both an anchor referencing the current block,
and a button to copy the content of the block.

#+name: Src blocks
#+begin_src emacs-lisp
(defadvice! org-html-src-block-collapsable (orig-fn src-block contents info)
  "Wrap the usual <pre> block in a <details>"
  :around #'org-html-src-block
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn src-block contents info)
    (let* ((properties (cadr src-block))
           (lang (mode-name-to-lang-name
                  (plist-get properties :language)))
           (name (plist-get properties :name))
           (ref (org-export-get-reference src-block info))
           (collapsed-p (member (or (org-export-read-attribute :attr_html src-block :collapsed)
                                    (plist-get info :collapsed))
                                '("y" "yes" "t" t "true" "all"))))
      (format
       "<details id='%s' class='code'%s><summary%s>%s</summary>
<div class='gutter'>
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>⎘</button>\
</div>
%s
</details>"
       ref
       (if collapsed-p "" " open")
       (if name " class='named'" "")
       (concat
        (when name (concat "<span class=\"name\">" name "</span>"))
        "<span class=\"lang\">" lang "</span>")
       ref
       (if name
           (replace-regexp-in-string (format "<pre\\( class=\"[^\"]+\"\\)? id=\"%s\">" ref) "<pre\\1>"
                                     (funcall orig-fn src-block contents info))
         (funcall orig-fn src-block contents info))))))

(defun mode-name-to-lang-name (mode)
  (or (cadr (assoc mode
                   '(("asymptote" "Asymptote")
                     ("awk" "Awk")
                     ("C" "C")
                     ("clojure" "Clojure")
                     ("css" "CSS")
                     ("D" "D")
                     ("ditaa" "ditaa")
                     ("dot" "Graphviz")
                     ("calc" "Emacs Calc")
                     ("emacs-lisp" "Emacs Lisp")
                     ("fortran" "Fortran")
                     ("gnuplot" "gnuplot")
                     ("haskell" "Haskell")
                     ("hledger" "hledger")
                     ("java" "Java")
                     ("js" "Javascript")
                     ("latex" "LaTeX")
                     ("ledger" "Ledger")
                     ("lisp" "Lisp")
                     ("lilypond" "Lilypond")
                     ("lua" "Lua")
                     ("matlab" "MATLAB")
                     ("mscgen" "Mscgen")
                     ("ocaml" "Objective Caml")
                     ("octave" "Octave")
                     ("org" "Org mode")
                     ("oz" "OZ")
                     ("plantuml" "Plantuml")
                     ("processing" "Processing.js")
                     ("python" "Python")
                     ("R" "R")
                     ("ruby" "Ruby")
                     ("sass" "Sass")
                     ("scheme" "Scheme")
                     ("screen" "Gnu Screen")
                     ("sed" "Sed")
                     ("sh" "shell")
                     ("sql" "SQL")
                     ("sqlite" "SQLite")
                     ("forth" "Forth")
                     ("io" "IO")
                     ("J" "J")
                     ("makefile" "Makefile")
                     ("maxima" "Maxima")
                     ("perl" "Perl")
                     ("picolisp" "Pico Lisp")
                     ("scala" "Scala")
                     ("shell" "Shell Script")
                     ("ebnf2ps" "ebfn2ps")
                     ("cpp" "C++")
                     ("abc" "ABC")
                     ("coq" "Coq")
                     ("groovy" "Groovy")
                     ("bash" "bash")
                     ("csh" "csh")
                     ("ash" "ash")
                     ("dash" "dash")
                     ("ksh" "ksh")
                     ("mksh" "mksh")
                     ("posh" "posh")
                     ("ada" "Ada")
                     ("asm" "Assembler")
                     ("caml" "Caml")
                     ("delphi" "Delphi")
                     ("html" "HTML")
                     ("idl" "IDL")
                     ("mercury" "Mercury")
                     ("metapost" "MetaPost")
                     ("modula-2" "Modula-2")
                     ("pascal" "Pascal")
                     ("ps" "PostScript")
                     ("prolog" "Prolog")
                     ("simula" "Simula")
                     ("tcl" "tcl")
                     ("tex" "LaTeX")
                     ("plain-tex" "TeX")
                     ("verilog" "Verilog")
                     ("vhdl" "VHDL")
                     ("xml" "XML")
                     ("nxml" "XML")
                     ("conf" "Configuration File"))))
      mode))
#+end_src

#+name: Example, fixed width, and property blocks
#+begin_src emacs-lisp
(defun org-html-block-collapsable (orig-fn block contents info)
  "Wrap the usual block in a <details>"
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn block contents info)
    (let ((ref (org-export-get-reference block info))
          (type (pcase (car block)
                  ('property-drawer "Properties")))
          (collapsed-default (pcase (car block)
                               ('property-drawer t)
                               (_ nil)))
          (collapsed-value (org-export-read-attribute :attr_html block :collapsed))
          (collapsed-p (or (member (org-export-read-attribute :attr_html block :collapsed)
                                   '("y" "yes" "t" t "true"))
                           (member (plist-get info :collapsed) '("all")))))
      (format
       "<details id='%s' class='code'%s>
<summary%s>%s</summary>
<div class='gutter'>\
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>⎘</button>\
</div>
%s\n
</details>"
       ref
       (if (or collapsed-p collapsed-default) "" " open")
       (if type " class='named'" "")
       (if type (format "<span class='type'>%s</span>" type) "")
       ref
       (funcall orig-fn block contents info)))))

(advice-add 'org-html-example-block   :around #'org-html-block-collapsable)
(advice-add 'org-html-fixed-width     :around #'org-html-block-collapsable)
(advice-add 'org-html-property-drawer :around #'org-html-block-collapsable)
#+end_src

**** Include extra font-locking in htmlize

Org uses [[https://github.com/hniksic/emacs-htmlize][htmlize.el]] to export buffers with syntax highlighting.

The works fantastically, for the most part. Minor modes that provide
font-locking are /not/ loaded, and so do not impact the result.

By enabling these modes in ~htmlize-before-hook~ we can correct this behaviour.

#+begin_src emacs-lisp
(add-hook 'htmlize-before-hook #'highlight-numbers--turn-on)
#+end_src

**** Handle table overflow
In order to accommodate wide tables ---particularly on mobile devices--- we want
to set a maximum width and scroll overflow. Unfortunately, this cannot be applied
directly to the ~table~ element, so we have to wrap it in a ~div~.

While we're at it, we can a link gutter, as we did with src blocks, and show the
~#+name~, if one is given.

#+begin_src emacs-lisp
(defadvice! org-html-table-wrapped (orig-fn table contents info)
  "Wrap the usual <table> in a <div>"
  :around #'org-html-table
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn table contents info)
    (let* ((name (plist-get (cadr table) :name))
           (ref (org-export-get-reference table info)))
      (format "<div id='%s' class='table'>
<div class='gutter'><a href='#%s'>#</a></div>
<div class='tabular'>
%s
</div>\
</div>"
              ref ref
              (if name
                  (replace-regexp-in-string (format "<table id=\"%s\"" ref) "<table"
                                            (funcall orig-fn table contents info))
                (funcall orig-fn table contents info))))))
#+end_src
**** TOC as a collapsable tree
The TOC is much nicer to navigate as a collapsable tree. Unfortunately we cannot
achieve this with CSS alone. Thankfully we can avoid JS though, by adapting the
TOC generation code to use a ~label~ for each item, and a hidden ~checkbox~ to keep
track of state.

To add this, we need to change one line in [[file:~/.emacs.d/.local/straight/repos/org-mode/lisp/ox-html.el::(format "<a href=\"#%s\">%s</a>"][org-html--format-toc-headline]].

Since we can actually accomplish the desired effect by adding advice /around/ the
function, without overriding it --- let's do that to reduce the bug surface of
this config a tad.
#+begin_src emacs-lisp
(defadvice! org-html--format-toc-headline-colapseable (orig-fn headline info)
  "Add a label and checkbox to `org-html--format-toc-headline's usual output,
to allow the TOC to be a collapseable tree."
  :around #'org-html--format-toc-headline
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn headline info)
    (let ((id (or (org-element-property :CUSTOM_ID headline)
                  (org-export-get-reference headline info))))
      (format "<input type='checkbox' id='toc--%s'/><label for='toc--%s'>%s</label>"
              id id (funcall orig-fn headline info)))))
#+end_src

Now, leaves (headings with no children) shouldn't have the ~label~ item. The
obvious way to achieve this is by including some /if no children.../ logic in
~org-html--format-toc-headline-colapseable~. Unfortunately, I can't my elisp isn't
up to par to extract the number of child headings from the mountain of info that
org provides.
#+begin_src emacs-lisp
(defadvice! org-html--toc-text-stripped-leaves (orig-fn toc-entries)
  "Remove label"
  :around #'org-html--toc-text
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn toc-entries)
    (replace-regexp-in-string "<input [^>]+><label [^>]+>\\(.+?\\)</label></li>" "\\1</li>"
                              (funcall orig-fn toc-entries))))
#+end_src
**** Make verbatim different to code
Since we have =verbatim= and ~code~, let's make use of the difference.

We can use ~code~ exclusively for code snippets and commands like: "calling
src_elisp{(message "Hello")} in batch-mode Emacs prints to stdout like ~echo~".
Then we can use =verbatim= for miscellaneous 'other monospace' like keyboard
shortcuts: "either =C-c C-c= or =C-g= is likely the most useful keybinding in Emacs",
or file names: "I keep my configuration in =~/.config/doom/=", among other things.

Then, styling these two cases differently can help improve clarity in a document.

#+begin_src emacs-lisp
(setq org-html-text-markup-alist
      '((bold . "<b>%s</b>")
        (code . "<code>%s</code>")
        (italic . "<i>%s</i>")
        (strike-through . "<del>%s</del>")
        (underline . "<span class=\"underline\">%s</span>")
        (verbatim . "<kbd>%s</kbd>")))
#+end_src
**** Change checkbox type
We also want to use HTML checkboxes, however we want to get a bit fancier than default
#+begin_src emacs-lisp
(appendq! org-html-checkbox-types
          '((html-span
             (on . "<span class='checkbox'></span>")
             (off . "<span class='checkbox'></span>")
             (trans . "<span class='checkbox'></span>"))))
(setq org-html-checkbox-type 'html-span)
#+end_src
- [ ] I'm yet to do this
- [-] Work in progress
- [X] This is done
**** Extra special strings
The ~org-html-special-string-regexps~ variable defines substitutions for:
+ =\-=, a shy hyphen
+ =---=, an em dash
+ =--=, an en dash
+ =...=, (horizontal) ellipses

However I think it would be nice if there was also a substitution for left/right
arrows (=->= and =<-=). This is a ~defconst~, but as you may tell from the amount of
advice in this config, I'm not above messing with things I'm not 'supposed' to.

The only minor complication is that =<= and =>= are converted to =&lt;= and =&gt;=
before this stage of output processing.

#+begin_src emacs-lisp
(pushnew! org-html-special-string-regexps
          '("-&gt;" . "&#8594;")
          '("&lt;-" . "&#8592;"))
#+end_src

**** Header anchors
I want to add GitHub-style links on hover for headings.
#+begin_src emacs-lisp
(defun org-export-html-headline-anchor (text backend info)
  (when (and (org-export-derived-backend-p backend 'html)
             org-fancy-html-export-mode)
    (unless (bound-and-true-p org-msg-export-in-progress)
      (replace-regexp-in-string
       "<h\\([0-9]\\) id=\"\\([a-z0-9-]+\\)\">\\(.*[^ ]\\)<\\/h[0-9]>" ; this is quite restrictive, but due to `org-reference-contraction' I can do this
       "<h\\1 id=\"\\2\">\\3<a aria-hidden=\"true\" href=\"#\\2\">#</a> </h\\1>"
       text))))

(add-to-list 'org-export-filter-headline-functions
             'org-export-html-headline-anchor)
#+end_src
**** Link previews
Sometimes it's nice to make a link particularly prominent, an embed/preview like
Twitter does would be nice I think.

We can do this without too much trouble by adding a new link type ever so
slightly different from =https= --- =Https=.

#+begin_src emacs-lisp
(org-link-set-parameters "Https"
                         :follow (lambda (url arg) (browse-url (concat "https:" url) arg))
                         :export #'org-url-fancy-export)
#+end_src

Then, if we can fetch a plist of the form src_elisp{(:title "..." :description
"..." :image "...")} for such links via a function ~org-url-unfurl-metadata~, we
can make a fancy export.

#+begin_src emacs-lisp
(defun org-url-fancy-export (url _desc backend)
  (let ((metadata (org-url-unfurl-metadata (concat "https:" url))))
    (cond
     ((org-export-derived-backend-p backend 'html)
      (concat
       "<div class=\"link-preview\">"
       (format "<a href=\"%s\">" (concat "https:" url))
       (when (plist-get metadata :image)
         (format "<img src=\"%s\"/>" (plist-get metadata :image)))
       "<small>"
       (replace-regexp-in-string "//\\(?:www\\.\\)?\\([^/]+\\)/?.*" "\\1" url)
       "</small><p>"
       (when (plist-get metadata :title)
         (concat "<b>" (org-html-encode-plain-text (plist-get metadata :title)) "</b></br>"))
       (when (plist-get metadata :description)
         (org-html-encode-plain-text (plist-get metadata :description)))
       "</p></a></div>"))
     (t url))))
#+end_src

Now we just need to actually implement that metadata extraction function.
#+begin_src emacs-lisp
(setq org-url-unfurl-metadata--cache nil)
(defun org-url-unfurl-metadata (url)
  (cdr (or (assoc url org-url-unfurl-metadata--cache)
           (car (push
                 (cons
                  url
                  (let* ((head-data
                          (-filter #'listp
                                   (cdaddr
                                    (with-current-buffer (progn (message "Fetching metadata from %s" url)
                                                                (url-retrieve-synchronously url t t 5))
                                      (goto-char (point-min))
                                      (delete-region (point-min) (- (search-forward "<head>") 6))
                                      (delete-region (search-forward "</head>") (point-max))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<script[^\u2800]+?</script>" nil t)
                                        (replace-match ""))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<style[^\u2800]+?</style>" nil t)
                                        (replace-match ""))
                                      (libxml-parse-html-region (point-min) (point-max))))))
                         (meta (delq nil
                                     (mapcar
                                      (lambda (tag)
                                        (when (eq 'meta (car tag))
                                          (cons (or (cdr (assoc 'name (cadr tag)))
                                                    (cdr (assoc 'property (cadr tag))))
                                                (cdr (assoc 'content (cadr tag))))))
                                      head-data))))
                    (let ((title (or (cdr (assoc "og:title" meta))
                                     (cdr (assoc "twitter:title" meta))
                                     (nth 2 (assq 'title head-data))))
                          (description (or (cdr (assoc "og:description" meta))
                                           (cdr (assoc "twitter:description" meta))
                                           (cdr (assoc "description" meta))))
                          (image (or (cdr (assoc "og:image" meta))
                                     (cdr (assoc "twitter:image" meta)))))
                      (when image
                        (setq image (replace-regexp-in-string
                                     "^/" (concat "https://" (replace-regexp-in-string "//\\([^/]+\\)/?.*" "\\1" url) "/")
                                     (replace-regexp-in-string
                                      "^//" "https://"
                                      image))))
                      (list :title title :description description :image image))))
                 org-url-unfurl-metadata--cache)))))
#+end_src

**** LaTeX Rendering
***** Pre-rendered
I consider ~dvisvgm~ to be a rather compelling option. However this isn't scaled
very well at the moment.
#+begin_src emacs-lisp
;; (setq-default org-html-with-latex `dvisvgm)
#+end_src

***** MathJax
If MathJax is used, we want to use version 3 instead of the default version 2.
Looking at a [[https://www.intmath.com/cg5/katex-mathjax-comparison.php][comparison]] we seem to find that it is ~5 times as fast, uses a
single file instead of multiple, but seems to be a bit bigger unfortunately.
Thankfully this can be mitigated my adding the ~async~ attribute to defer loading.

#+begin_src emacs-lisp
(setq org-html-mathjax-options
      '((path "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" )
        (scale "1")
        (autonumber "ams")
        (multlinewidth "85%")
        (tagindent ".8em")
        (tagside "right")))

(setq org-html-mathjax-template
      "<script>
MathJax = {
  chtml: {
    scale: %SCALE
  },
  svg: {
    scale: %SCALE,
    fontCache: \"global\"
  },
  tex: {
    tags: \"%AUTONUMBER\",
    multlineWidth: \"%MULTLINEWIDTH\",
    tagSide: \"%TAGSIDE\",
    tagIndent: \"%TAGINDENT\"
  }
};
</script>
<script id=\"MathJax-script\" async
        src=\"%PATH\"></script>")
#+end_src
*** LaTeX Export
**** Compiling
By default Org uses ~pdflatex~ \times 3 + ~bibtex~. This simply won't do in our
modern world. ~latexmk~ + ~biber~ (which is used automatically with ~latexmk~) is a
simply superior combination.

#+begin_src emacs-lisp
;; org-latex-compilers = ("pdflatex" "xelatex" "lualatex"), which are the possible values for %latex
(setq org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.

**** Nicer checkboxes

We'll assume that thanks to the clever preamble the various custom =\checkbox...=
commands below are defined.

#+begin_src emacs-lisp
(defun +org-export-latex-fancy-item-checkboxes (text backend info)
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string
     "\\\\item\\[{$\\\\\\(\\w+\\)$}\\]"
     (lambda (fullmatch)
       (concat "\\\\item[" (pcase (substring fullmatch 9 -3) ; content of capture group
                             ("square"   "\\\\checkboxUnchecked")
                             ("boxminus" "\\\\checkboxTransitive")
                             ("boxtimes" "\\\\checkboxChecked")
                             (_ (substring fullmatch 9 -3))) "]"))
     text)))

(add-to-list 'org-export-filter-item-functions
             '+org-export-latex-fancy-item-checkboxes)
#+end_src

**** Class templates

#+begin_src emacs-lisp :noweb no-export
(after! ox-latex
  (add-to-list 'org-latex-classes
               '("scr-article"
                 "\\documentclass{scrartcl}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("blank"
                 "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("bmc-article"
                 "\\documentclass[article,code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("bmc"
                 "\\documentclass[code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))

(setq org-latex-default-class "scr-article"
      org-latex-tables-booktabs t
      org-latex-hyperref-template "
<<latex-fancy-hyperref>>
")
#+end_src


The =hyperref= setup needs to be handled separately however.
#+name: latex-fancy-hyperref
#+begin_src LaTeX
\\colorlet{greenyblue}{blue!70!green}
\\colorlet{blueygreen}{blue!40!green}
\\providecolor{link}{named}{greenyblue}
\\providecolor{cite}{named}{blueygreen}
\\hypersetup{
  pdfauthor={%a},
    pdftitle={%t},
      pdfkeywords={%k},
        pdfsubject={%d},
          pdfcreator={%c},
            pdflang={%L},
              breaklinks=true,
              colorlinks=true,
              linkcolor=,
              urlcolor=link,
              citecolor=cite\n}
            \\urlstyle{same}
#+end_src

**** A cleverer preamble
***** Use case
We often want particular snippets of LaTeX in our documents preambles.
It's a pain to have to work out / remember them every time.
For example, I almost always want to include the snippet below.

#+name: org-latex-embed-files-preamble
#+begin_src LaTeX
\\usepackage[main,include]{embedall}
\\IfFileExists{./\\jobname.org}{\\embedfile[desc=The original file]{\\jobname.org}}{}
#+end_src

We could have every package we could possibly need in every one of
~org-latex-classes~, but that's /horribly/ inefficient and I don't want to think
about maintaining that.

Instead we can provide some granularity by splitting up the features we want,
and then take the experience to a whole new level by implementing a system to
automatically detect which features are desired and generating a preamble that
provides these features.

***** Conditional Content

Let's consider content we want in particular situations.

Captions could do with a bit of tweaking such that
+ You can easily have multiple captions
+ Links to figures take you to the /top/ of the figure (not the bottom)
+ Caption labels could do with being emphasised slightly more
+ Multiline captions should run ragged-right, but only when then span more than
  one line

#+name: org-latex-caption-preamble
#+begin_src LaTeX
\\usepackage{subcaption}
\\usepackage[hypcap=true]{caption}
\\setkomafont{caption}{\\sffamily\\small}
\\setkomafont{captionlabel}{\\upshape\\bfseries}
\\captionsetup{justification=raggedright,singlelinecheck=true}
\\usepackage{capt-of} % required by Org
#+end_src

The default checkboxes look rather ugly, so let's provide some prettier alternatives.

#+name: org-latex-checkbox-preamble
#+begin_src LaTeX
\\newcommand{\\checkboxUnchecked}{$\\square$}
\\newcommand{\\checkboxTransitive}{\\rlap{\\raisebox{-0.1ex}{\\hspace{0.35ex}\\Large\\textbf -}}$\\square$}
\\newcommand{\\checkboxChecked}{\\rlap{\\raisebox{0.2ex}{\\hspace{0.35ex}\\scriptsize \\ding{52}}}$\\square$}
#+end_src

It's nice to have "message blocks", things like info/warning/error/success.
A LaTeX macro should make them trivial to create.

#+name: org-latex-box-preamble
#+begin_src LaTeX
% args = #1 Name, #2 Colour, #3 Ding, #4 Label
\\newcommand{\\defsimplebox}[4]{%
  \\definecolor{#1}{HTML}{#2}
  \\newenvironment{#1}[1][]
  {%
    \\par\\vspace{-0.7\\baselineskip}%
    \\textcolor{#1}{#3} \\textcolor{#1}{\\textbf{\\def\\temp{##1}\\ifx\\temp\\empty#4\\else##1\\fi}}%
    \\vspace{-0.8\\baselineskip}
    \\begin{addmargin}[1em]{1em}
  }{%
    \\end{addmargin}
    \\vspace{-0.5\\baselineskip}
  }%
}
#+end_src

Lastly, we will pass this content into some global variables we for ease of
access.

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-embed-files-preamble "
<<org-latex-embed-files-preamble>>
"
  "Preamble that embeds files within the pdf.")

(defvar org-latex-caption-preamble "
<<org-latex-caption-preamble>>
"
  "Preamble that improves captions.")

(defvar org-latex-checkbox-preamble "
<<org-latex-checkbox-preamble>>
"
  "Preamble that improves checkboxes.")

(defvar org-latex-box-preamble "
<<org-latex-box-preamble>>
"
  "Preamble that provides a macro for custom boxes.")
#+end_src

In the "universal preamble", we already embed the source =.org= file, but it would
be nice to embed all the tangled files. This is fairly easy to accomplish using
a cannibalised version of ~org-babel-tangle~ which just collects the file names of
each block that is tangled.

#+begin_src emacs-lisp
(defun org-babel-tangle-files ()
  "All files that may be tangled to.
Uses a stripped-down version of `org-babel-tangle'"
  (let (files)
    (save-excursion
      (mapc ;; map over all languages
       (lambda (by-lang)
         (let* ((lang (car by-lang))
                (specs (cdr by-lang))
                (ext (or (cdr (assoc lang org-babel-tangle-lang-exts)) lang)))
           (mapc
            (lambda (spec)
              (let ((get-spec (lambda (name) (cdr (assoc name (nth 4 spec))))))
                (let* ((tangle (funcall get-spec :tangle))
                       (base-name (cond
                                   ((string= "yes" tangle)
                                    (file-name-sans-extension
                                     (nth 1 spec)))
                                   ((string= "no" tangle) nil)
                                   ((> (length tangle) 0) tangle)))
                       (file-name (when base-name
                                    ;; decide if we want to add ext to base-name
                                    (if (and ext (string= "yes" tangle))
                                        (concat base-name "." ext) base-name))))
                  (push file-name files))))
            specs)))
       (org-babel-tangle-collect-blocks)))
    (delq nil (cl-delete-duplicates files :test #'string=))))
#+end_src

From here it is trivial to map each file to a form which embeds the file if it
exists.
#+begin_src emacs-lisp
(defun org-latex-embed-tangled-files ()
  "Return a string that uses embedfile to embed all tangled files."
  (mapconcat
   (lambda (tangle-file)
     (format "\\IfFileExists{%1$s}{\\embedfile[desc=A tangled file]{%1$s}}{}"
             (->> tangle-file
               (replace-regexp-in-string "\\\\" "\\\\\\\\")
               (replace-regexp-in-string "~" "\\\\string~"))))
   (org-babel-tangle-files)
   "\n"))
#+end_src

***** Content-feature-preamble association

Initially this idea was implemented with an alist that associated a construct
that would search the current Org file for an indication that some feature was
needed, with a LaTeX snippet to be inserted in the preamble which would provide
that feature.
This is all well and good when there is a bijection between detected features
and the LaTeX code needed to support those features, but in many cases this
relation is not injective.

To better model the reality of the situation, I add an extra layer to this
process where each detected feature gives a list of required "feature flags".
Simply be merging the lists of feature flags we no longer have to require
injectivity to avoid LaTeX duplication. Then the extra layer forms a bijection
between there feature flags and a specification which can be used to implement
the feature.

This model also provides a number of nice secondary benefits, such as a simple
implementation of feature dependency.

#+begin_src dot :file misc/org-latex-clever-preamble.svg :exports none
digraph {
graph [bgcolor="transparent"];
node  [shape="underline" penwidth="2" width="1.3" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
edge  [color="#aaaaaa" penwidth="1.2"]
rankdir=LR

node[group=a,color="#2ec27e"]
"file:*.svg"
"file:*.jpeg"
"file:*.png"
"#+caption"
node[group=b,color="#f5c211"]
"svg"
"image"
"caption"
node[group=c,color="#813d9c"]
"(TeX) svg"
"(TeX) graphicx"
"(TeX) caption"

"file:*.svg" -> "svg" -> "(TeX) svg"
"file:*.jpeg" -> "image" -> "(TeX) graphicx"
"file:*.png" -> "image"
"(TeX) svg":s -> "(TeX) graphicx":n [constraint=false]
"#+caption" -> "caption" -> "(TeX) caption"
}
#+end_src

#+caption: Association between Org features, feature flags, and LaTeX snippets required.
#+attr_html: :class invertible :alt DAG showing how Org features flow through to LaTeX :style max-width:min(24em,100%)
#+attr_latex: :width 0.6\linewidth
[[file:misc/org-latex-clever-preamble.svg]]

First we will implement the feature detection component of this model. I'd like
this to be able to use as much state information as possible, so the feature
tests should be very versatile.

#+begin_src emacs-lisp
(defvar org-latex-embed-files t
  "Embed the source .org, .tex, and any tangled files.")
(defvar org-latex-use-microtype t
  "Use the microtype pakage.")
(defvar org-latex-italic-quotes t
  "Make \"quote\" environments italic.")
(defvar org-latex-par-sep t
  "Vertically seperate paragraphs, and remove indentation.")

(defvar org-latex-conditional-features
  '(("\\[\\[file:\\(?:[^]]\\|\\\\\\]\\)+?\\.\\(?:eps\\|pdf\\|png\\|jpeg\\|jpg\\|jbig2\\)\\]\\]" . image)
    ("\\[\\[file:\\(?:[^]]+?\\|\\\\\\]\\)\\.svg\\]\\]" . svg)
    ("\\\\(\\|\\\\\\[\\|\\\\begin{\\(?:math\\|displaymath\\|equation\\|align\\|flalign\\|multiline\\|gather\\)[a-z]*\\*?}" . maths)
    ("^[ \t]*|" . table)
    ("cref:\\|\\cref{" . cleveref)
    ("[;\\\\]?\\b[A-Z][A-Z]+s?[^A-Za-z]" . acronym)
    ("\\+[^ ].*[^ ]\\+\\|_[^ ].*[^ ]_\\|\\\\uu?line\\|\\\\uwave\\|\\\\sout\\|\\\\xout\\|\\\\dashuline\\|\\dotuline\\|\\markoverwith" . underline)
    (":float wrap" . float-wrap)
    (":float sideways" . rotate)
    ("^[ \t]*#\\+caption:\\|\\\\caption" . caption)
    (org-latex-use-microtype . microtype)
    ((and org-latex-italic-quotes "^[ \t]*#\\+begin_quote\\|\\\\begin{quote}") . italic-quotes)
    (org-latex-par-sep . par-sep)
    ((org-latex-embed-tangled-files) . embed-files)
    ((and org-latex-embed-files "^[ \t]*#\\+begin_src\\|^[ \t]*#\\+BEGIN_SRC") . embed-tangled)
    ("^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\|[A-Za-z]+[.)]\\) \\[[ -X]\\]" . checkbox)
    ("^[ \t]*#\\+begin_warning\\|\\\\begin{warning}" . box-warning)
    ("^[ \t]*#\\+begin_info\\|\\\\begin{info}"       . box-info)
    ("^[ \t]*#\\+begin_success\\|\\\\begin{success}" . box-success)
    ("^[ \t]*#\\+begin_error\\|\\\\begin{error}"     . box-error))
  "Org feature tests and associated LaTeX feature flags.

Alist where the car is a test for the presense of the feature,
and the cdr is either a single feature symbol or list of feature symbols.

When a string, it is used as a regex search in the buffer.
The feature is registered as present when there is a match.

The car can also be a
- symbol, the value of which is fetched
- function, which is called with info as an argument
- list, which is `eval'uated

If the symbol, function, or list produces a string: that is used as a regex
search in the buffer. Otherwise any non-nil return value will indicate the
existance of the feature.")
#+end_src

Then we provide a way to generate the preamble that provides those features.
In addition to the features named in ~org-latex-conditional-features~ we'll also
create /meta-features/, which can be required by other features (with =:requires=),
or be active by default (=:eager t=). For further control I some features may only
be used when certain other features are active (with =:when=), and masked by other
features (with =:prevents=). I will use the convention of starting meta-features
with =.=, and =:eager= features with =!= to make their nature more readily apparent.

Another consideration in LaTeX is load order, which matters in some cases.
Beyond that, it's nice to have some sort of sensible ordering. For this I'll
introduce an =:order= keyword. Using this I'll arrange snippets as follows.

+ =-2= Embed files setup
+ =-1= Extra file embedding
+ =0= Typography
  - =0= Fonts themselves
  - =0.1= Typographic tweaks (=microtype=)
  - =0.2= Maths setup
  - =0.3= Maths font
  - =0.4= Extra text shaping (~\acr~)
  - =0.5-0.9= Miscellaneous text modifications, trying to put shorter snippets first
+ =1= (/default/)
+ =2= Tables and figures
+ =3= Miscellaneous short content
+ =4= Fancy boxes

#+begin_src emacs-lisp
(defvar org-latex-feature-implementations
  '((image         :snippet "\\usepackage{graphicx}" :order 2)
    (svg           :snippet "\\usepackage{svg}" :order 2)
    (maths         :snippet "\\usepackage[nofont]{bmc-maths}" :order 0.2)
    (table         :snippet "\\usepackage{longtable}\n\\usepackage{booktabs}" :order 2)
    (cleveref      :snippet "\\usepackage{cleveref}" :order 1) ; after bmc-maths
    (underline     :snippet "\\usepackage[normalem]{ulem}" :order 0.5)
    (float-wrap    :snippet "\\usepackage{wrapfig}" :order 2)
    (rotate        :snippet "\\usepackage{rotating}" :order 2)
    (caption       :snippet org-latex-caption-preamble :order 2.1)
    (microtype     :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}\n" :order 0.1)
    (embed-files   :snippet org-latex-embed-files-preamble :order -2)
    (embed-tangled :requires embed-files :snippet (concat (org-latex-embed-tangled-files) "\n") :order -1)
    (acronym       :snippet "\\newcommand{\\acr}[1]{\\protect\\textls*[110]{\\scshape #1}}\n\\newcommand{\\acrs}{\\protect\\scalebox{.91}[.84]{\\hspace{0.15ex}s}}" :order 0.4)
    (italic-quotes :snippet "\\renewcommand{\\quote}{\\list{}{\\rightmargin\\leftmargin}\\item\\relax\\em}\n" :order 0.5)
    (par-sep       :snippet "\\setlength{\\parskip}{\\baselineskip}\n\\setlength{\\parindent}{0pt}\n" :order 0.5)
    (.pifont       :snippet "\\usepackage{pifont}")
    (checkbox      :requires .pifont :order 3
                   :snippet (concat (unless (memq 'maths features)
                                      "\\usepackage{amssymb} % provides \\square")
                                    org-latex-checkbox-preamble))
    (.fancy-box    :requires .pifont    :snippet org-latex-box-preamble :order 3.9)
    (box-warning   :requires .fancy-box :snippet "\\defsimplebox{warning}{e66100}{\\ding{68}}{Warning}" :order 4)
    (box-info      :requires .fancy-box :snippet "\\defsimplebox{info}{3584e4}{\\ding{68}}{Information}" :order 4)
    (box-success   :requires .fancy-box :snippet "\\defsimplebox{success}{26a269}{\\ding{68}}{\\vspace{-\\baselineskip}}" :order 4)
    (box-error     :requires .fancy-box :snippet "\\defsimplebox{error}{c01c28}{\\ding{68}}{Important}" :order 4))
  "LaTeX features and details required to implement them.

List where the car is the feature symbol, and the rest forms a plist with the
following keys:
- :snippet, which may be either
  - a string which should be included in the preamble
  - a symbol, the value of which is included in the preamble
  - a function, which is evaluated with the list of feature flags as its
    single argument. The result of which is included in the preamble
  - a list, which is passed to `eval', with a list of feature flags available
    as \"features\".
- :requires, a feature or list of features that must be available
- :when, a feature or list of features that when all available should cause this
    to be automatically enabled.
- :prevents, a feature or list of features that should be masked
- :order, for when ordering is important. Lower values appear first.
    The default is 0.

Features that start with ! will be eagerly loaded, i.e. without being detected.")
#+end_src

***** Feature determination

Now that we have ~org-latex-conditional-features~ defined, we need to use it to
extract a list of features found in an Org buffer.

#+begin_src emacs-lisp
(defun org-latex-detect-features (&optional buffer info)
  "List features from `org-latex-conditional-features' detected in BUFFER."
  (let ((case-fold-search nil))
    (with-current-buffer (or buffer (current-buffer))
      (delete-dups
       (apply #'append
              (mapcar (lambda (construct-feature)
                        (when (let ((out (pcase (car construct-feature)
                                           ((pred stringp) (car construct-feature))
                                           ((pred functionp) (funcall (car construct-feature) info))
                                           ((pred listp) (eval (car construct-feature)))
                                           ((pred symbolp) (symbol-value (car construct-feature)))
                                           (_ (user-error "org-latex-conditional-features key %s unable to be used" (car construct-feature))))))
                                (if (stringp out)
                                    (save-excursion
                                      (goto-char (point-min))
                                      (re-search-forward out nil t))
                                  out))
                          (if (listp (cdr construct-feature)) (cdr construct-feature) (list (cdr construct-feature)))))
                      org-latex-conditional-features))))))
#+end_src

***** Preamble generation

Once a list of required features has been determined, we want to use
~org-latex-feature-implementations~ to generate the LaTeX which should be inserted
into the preamble to provide those features.

First we want to process our fancy keywords in ~org-latex-feature-implementations~
to produce an /expanded/ list of features. We'll do that by performing the
following steps.
+ The dependencies for each listed feature are added to feature list
  (src_elisp{:requires}).
+ The src_elisp{:when} conditions of each feature, and available features with
  src_elisp{:eager t}, are evaluated, and added/removed accordingly
+ Any features present in a src_elisp{:prevents} value are removed
+ The feature list is scrubbed of duplicates
+ The feature list is sorted by src_elisp{:order} (ascending)

#+begin_src emacs-lisp
(defun org-latex-expand-features (features)
  "For each feature in FEATURES process :requires, :when, and :prevents keywords and sort according to :order."
  (dolist (feature features)
    (unless (assoc feature org-latex-feature-implementations)
      (error "Feature %s not provided in org-latex-feature-implementations" feature)))
  (setq current features)
  (while current
    (when-let ((requirements (plist-get (cdr (assq (car current) org-latex-feature-implementations)) :requires)))
      (setcdr current (if (listp requirements)
                          (append requirements (cdr current))
                        (cons requirements (cdr current)))))
    (setq current (cdr current)))
  (dolist (potential-feature
           (append features (delq nil (mapcar (lambda (feat)
                                                (when (plist-get (cdr feat) :eager)
                                                  (car feat)))
                                              org-latex-feature-implementations))))
    (when-let ((prerequisites (plist-get (cdr (assoc potential-feature org-latex-feature-implementations)) :when)))
      (setf features (if (if (listp prerequisites)
                             (cl-every (lambda (preq) (memq preq features)) prerequisites)
                           (memq prerequisites features))
                         (append (list potential-feature) features)
                       (delq potential-feature features)))))
  (dolist (feature features)
    (when-let ((prevents (plist-get (cdr (assoc feature org-latex-feature-implementations)) :prevents)))
      (setf features (cl-set-difference features (if (listp prevents) prevents (list prevents))))))
  (sort (delete-dups features)
        (lambda (feat1 feat2)
          (if (< (or (plist-get (cdr (assoc feat1 org-latex-feature-implementations)) :order) 1)
                 (or (plist-get (cdr (assoc feat2 org-latex-feature-implementations)) :order) 1))
              t nil))))
#+end_src

Now that we have a nice list of the final features to use, we can just pull out
their snippets and join the result together.

#+begin_src emacs-lisp
(defun org-latex-generate-features-preamble (features)
  "Generate the LaTeX preamble content required to provide FEATURES.
This is done according to `org-latex-feature-implementations'"
  (let ((expanded-features (org-latex-expand-features features)))
    (concat
     (format "\n%% features: %s\n" expanded-features)
     (mapconcat (lambda (feature)
                  (when-let ((snippet (plist-get (cdr (assoc feature org-latex-feature-implementations)) :snippet)))
                    (concat
                     (pcase snippet
                       ((pred stringp) snippet)
                       ((pred functionp) (funcall snippet features))
                       ((pred listp) (eval `(let ((features ',features)) (,@snippet))))
                       ((pred symbolp) (symbol-value snippet))
                       (_ (user-error "org-latex-feature-implementations :snippet value %s unable to be used" snippet)))
                     "\n")))
                expanded-features
                "")
     "% end features\n")))
#+end_src

Then Org needs to be advised to actually use this generated preamble content.

#+begin_src emacs-lisp
(defvar info--tmp nil)

(defadvice! org-latex-save-info (info &optional t_ s_)
  :before #'org-latex-make-preamble
  (setq info--tmp info))

(defadvice! org-splice-latex-header-and-generated-preamble-a (orig-fn tpl def-pkg pkg snippets-p &optional extra)
  "Dynamically insert preamble content based on `org-latex-conditional-preambles'."
  :around #'org-splice-latex-header
  (let ((header (funcall orig-fn tpl def-pkg pkg snippets-p extra)))
    (if snippets-p header
      (concat header
              (org-latex-generate-features-preamble (org-latex-detect-features nil info--tmp))
              "\n"))))
#+end_src

My use of ~info--tmp~ is somewhat hacky. When I try to upstream this, this should
become much cleaner as I can pass info through by directly modifying
~org-latex-make-preamble~.

***** Reduce default packages

Thanks to our additions, we can remove a few packages from
~org-latex-default-packages-alist~.

There are also some obsolete entries in the default value, specifically
+ =grffile='s capabilities are built into the current version of =graphicx=
+ =textcomp='s functionality has been included in LaTeX's core for a while now

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t ("pdflatex"))
        ("T1" "fontenc" t ("pdflatex"))
        ("" "xcolor" nil) ; Generally useful
        ("" "hyperref" nil)))
#+end_src
**** Font collections

Using the lovely conditional preamble, I'll define a number of font collections
that can be used for LaTeX exports. Who knows, maybe I'll use it with other
export formats too at some point.

To start with I'll create a default state variable and register =fontset= as part
of =#+options=.

#+begin_src emacs-lisp
(defvar org-latex-default-fontset 'alegreya
  "Fontset from `org-latex-fontsets' to use by default.
As cm (computer modern) is TeX's default, that causes nothing
to be added to the document.

If \"nil\" no custom fonts will ever be used.")

(eval '(cl-pushnew '(:latex-font-set nil "fontset" org-latex-default-fontset)
                   (org-export-backend-options (org-export-get-backend 'latex))))
#+end_src

Then a function is needed to generate a LaTeX snippet which applies the fontset. It
would be nice if this could be done for individual styles and use different
styles as the main document font. If the individual typefaces for a fontset are
defined individually as
src_elisp{:serif}, src_elisp{:sans}, src_elisp{:mono}, and src_elisp{:maths}.
I can use those to generate LaTeX for subsets of the full fontset. Then, if I
don't let any fontset names have =-= in them, I can use =-sans= and =-mono= as
suffixes that specify the document font to use.

#+begin_src emacs-lisp
(defun org-latex-fontset-entry ()
  "Get the fontset spec of the current file.
Has format \"name\" or \"name-style\" where 'name' is one of
the cars in `org-latex-fontsets'."
  (let ((fontset-spec
         (symbol-name
          (or (car (delq nil
                         (mapcar
                          (lambda (opt-line)
                            (plist-get (org-export--parse-option-keyword opt-line 'latex)
                                       :latex-font-set))
                          (cdar (org-collect-keywords '("OPTIONS"))))))
              org-latex-default-fontset))))
    (cons (intern (car (split-string fontset-spec "-")))
          (when (cadr (split-string fontset-spec "-"))
            (intern (concat ":" (cadr (split-string fontset-spec "-"))))))))

(defun org-latex-fontset (&rest desired-styles)
  "Generate a LaTeX preamble snippet which applies the current fontset for DESIRED-STYLES."
  (let* ((fontset-spec (org-latex-fontset-entry))
         (fontset (alist-get (car fontset-spec) org-latex-fontsets)))
    (if fontset
        (concat
         (mapconcat
          (lambda (style)
            (when (plist-get fontset style)
              (concat (plist-get fontset style) "\n")))
          desired-styles
          "")
         (when (memq (cdr fontset-spec) desired-styles)
           (pcase (cdr fontset-spec)
             (:serif "\\renewcommand{\\familydefault}{\\rmdefault}\n")
             (:sans "\\renewcommand{\\familydefault}{\\sfdefault}\n")
             (:mono "\\renewcommand{\\familydefault}{\\ttdefault}\n"))))
      (error "Font-set %s is not provided in org-latex-fontsets" (car fontset-spec)))))
#+end_src

Now that all the functionality has been implemented, we should hook it into our
preamble generation.

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '(org-latex-default-fontset . custom-font) t)
(add-to-list 'org-latex-feature-implementations '(custom-font :snippet (org-latex-fontset :serif :sans :mono) :order 0) t)
(add-to-list 'org-latex-feature-implementations '(.custom-maths-font :eager t :when (custom-font maths) :snippet (org-latex-fontset :maths) :order 0.3) t)
#+end_src

Finally, we just need to add some fonts.

#+begin_src emacs-lisp
(defvar org-latex-fontsets
  '((cm nil) ; computer modern
    (alegreya
     :serif "\\usepackage[osf]{Alegreya}"
     :sans "\\usepackage{AlegreyaSans}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (biolinum
     :serif "\\usepackage[osf]{libertineRoman}"
     :sans "\\usepackage[sfdefault,osf]{biolinum}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[libertine,varvw]{newtxmath}")
    (fira
     :sans "\\usepackage[sfdefault,scale=0.85]{FiraSans}"
     :mono "\\usepackage[scale=0.80]{FiraMono}"
     :maths "\\usepackage{newtxsf} % change to firamath in future?")
    (kp
     :serif "\\usepackage{kpfonts}")
    (newpx
     :serif "\\usepackage{newpxtext}"
     :sans "\\usepackage{gillius}"
     :mono "\\usepackage[scale=0.9]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (noto
     :serif "\\usepackage[osf]{noto-serif}"
     :sans "\\usepackage[osf]{noto-sans}"
     :mono "\\usepackage[scale=0.96]{noto-mono}"
     ;; Wait till TeXlive 2021 is released, use notomath
     :maths "\\usepackage{newtxmath}")
    (plex
     :serif "\\usepackage{plex-serif}"
     :sans "\\usepackage{plex-sans}"
     :mono "\\usepackage[scale=0.95]{plex-mono}"
     :maths "\\usepackage{newtxmath}") ; may be plex-based in future
    (source
     :serif "\\usepackage[osf]{sourceserifpro}"
     :sans "\\usepackage[osf]{sourcesanspro}"
     :mono "\\usepackage[scale=0.95]{sourcecodepro}"
     :maths "\\usepackage{newtxmath}") ; may be sourceserifpro-based in future
    (times
     :serif "\\usepackage{newtxtext}"
     :maths "\\usepackage{newtxmath}"))
  "Alist of fontset specifications.
Each car is the name of the fontset (which cannot include \"-\").

Each cdr is a plist with (optional) keys :serif, :sans, :mono, and :maths.
A key's value is a LaTeX snippet which loads such a font.")
#+end_src

When we're using Alegreya we can apply a lovely little tweak to =tabular= which
(locally) changes the figures used to lining fixed-width.

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '((string= (car (org-latex-fontset-entry)) "alegreya") . alegreya-typeface))
(add-to-list 'org-latex-feature-implementations '(alegreya-typeface) t)
(add-to-list 'org-latex-feature-implementations'(.alegreya-tabular-figures :eager t :when (alegreya-typeface table) :order 0.5 :snippet "
\\makeatletter
% tabular lining figures in tables
\\renewcommand{\\tabular}{\\AlegreyaTLF\\let\\@halignto\\@empty\\@tabular}
\\makeatother\n") t)
#+end_src

Due to the Alegreya's metrics, the =\LaTeX= symbol doesn't quite look right. We
can correct for this by redefining it with subtlety shifted kerning.

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '("LaTeX" . latex-symbol))
(add-to-list 'org-latex-feature-implementations '(latex-symbol :when alegreya-typeface :order 0.5 :snippet "
\\makeatletter
% Kerning around the A needs adjusting
\\DeclareRobustCommand{\\LaTeX}{L\\kern-.24em%
        {\\sbox\\z@ T%
         \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts
                              \\fontsize\\sf@size\\z@
                              \\math@fontsfalse\\selectfont
                              A}%
                        \\vss}%
        }%
        \\kern-.10em%
        \\TeX}
\\makeatother\n") t)
#+end_src

**** Cover page

To make a nice cover page, a simple method that comes to mind is just redefining
=\maketitle=. To get precise control over the positioning we'll use the =tikz=
package, and then add in the Tikz libraries =calc= and =shapes.geometric= to make
some nice decorations for the background.

I'll start off by setting up the required additions to the preamble.
This will accomplish the following:
+ Load the required packages
+ Redefine =\maketitle=
+ Draw an Org icon with Tikz to use in the cover page (it's a little easter egg)
+ Start a new page after the table of contents by redefining =\tableofcontents=

#+name: latex-cover-page
#+begin_src LaTeX
\\usepackage{tikz}
\\usetikzlibrary{shapes.geometric}
\\usetikzlibrary{calc}

\\newsavebox\\orgicon
\\begin{lrbox}{\\orgicon}
\\begin{tikzpicture}[y=0.80pt, x=0.80pt, inner sep=0pt, outer sep=0pt]
\\path[fill=black!6] (16.15,24.00) .. controls (15.58,24.00) and (13.99,20.69) .. (12.77,18.06)arc(215.55:180.20:2.19) .. controls (12.33,19.91) and (11.27,19.09) .. (11.43,18.05) .. controls (11.36,18.09) and (10.17,17.83) .. (10.17,17.82) .. controls (9.94,18.75) and (9.37,19.44) .. (9.02,18.39) .. controls (8.32,16.72) and (8.14,15.40) .. (9.13,13.80) .. controls (8.22,9.74) and (2.18,7.75) .. (2.81,4.47) .. controls (2.99,4.47) and (4.45,0.99) .. (9.15,2.41) .. controls (14.71,3.99) and (17.77,0.30) .. (18.13,0.04) .. controls (18.65,-0.49) and (16.78,4.61) .. (12.83,6.90) .. controls (10.49,8.18) and (11.96,10.38) .. (12.12,11.15) .. controls (12.12,11.15) and (14.00,9.84) .. (15.36,11.85) .. controls (16.58,11.53) and (17.40,12.07) .. (18.46,11.69) .. controls (19.10,11.41) and (21.79,11.58) .. (20.79,13.08) .. controls (20.79,13.08) and (21.71,13.90) .. (21.80,13.99) .. controls (21.97,14.75) and (21.59,14.91) .. (21.47,15.12) .. controls (21.44,15.60) and (21.04,15.79) .. (20.55,15.44) .. controls (19.45,15.64) and (18.36,15.55) .. (17.83,15.59) .. controls (16.65,15.76) and (15.67,16.38) .. (15.67,16.38) .. controls (15.40,17.19) and (14.82,17.01) .. (14.09,17.32) .. controls (14.70,18.69) and (14.76,19.32) .. (15.50,21.32) .. controls (15.76,22.37) and (16.54,24.00) .. (16.15,24.00) -- cycle(7.83,16.74) .. controls (6.83,15.71) and (5.72,15.70) .. (4.05,15.42) .. controls (2.75,15.19) and (0.39,12.97) .. (0.02,10.68) .. controls (-0.02,10.07) and (-0.06,8.50) .. (0.45,7.18) .. controls (0.94,6.05) and (1.27,5.45) .. (2.29,4.85) .. controls (1.41,8.02) and (7.59,10.18) .. (8.55,13.80) -- (8.55,13.80) .. controls (7.73,15.00) and (7.80,15.64) .. (7.83,16.74) -- cycle;
\\end{tikzpicture}
\\end{lrbox}

\\makeatletter
\\g@addto@macro\\tableofcontents{\\clearpage}
\\renewcommand\\maketitle{
  \\thispagestyle{empty}
  \\hyphenpenalty=10000 % hyphens look bad in titles
  \\renewcommand{\\baselinestretch}{1.1}
  \\let\\oldtoday\\today
  \\renewcommand{\\today}{\\LARGE\\number\\year\\\\\\large%
    \\ifcase \\month \\or Jan\\or Feb\\or Mar\\or Apr\\or May \\or Jun\\or Jul\\or Aug\\or Sep\\or Oct\\or Nov\\or Dec\\fi
    ~\\number\\day}
  \\begin{tikzpicture}[remember picture,overlay]
  %% Background Polygons %%
  \\foreach \\i in {2.5,...,22} % bottom left
  {\\node[rounded corners,black!3.5,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.west)+(2.5,-4.2)$) {} ;}
  \\foreach \\i in {0.5,...,22} % top left
  {\\node[rounded corners,black!5,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.north west)+(2.5,2)$) {} ;}
  \\node[rounded corners,fill=black!4,regular polygon,regular polygon sides=6, minimum size=5.5 cm,ultra thick] at ($(current page.north west)+(2.5,2)$) {};
  \\foreach \\i in {0.5,...,24} % top right
  {\\node[rounded corners,black!2,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.north east)+(0,-8.5)$) {} ;}
  \\node[fill=black!3,rounded corners,regular polygon,regular polygon sides=6, minimum size=2.5 cm,ultra thick] at ($(current page.north east)+(0,-8.5)$) {};
  \\foreach \\i in {21,...,3} % bottom right
  {\\node[black!3,rounded corners,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.south east)+(-1.5,0.75)$) {} ;}
  \\node[fill=black!3,rounded corners,regular polygon,regular polygon sides=6, minimum size=2 cm,ultra thick] at ($(current page.south east)+(-1.5,0.75)$) {};
  \\node[align=center, scale=1.4] at ($(current page.south east)+(-1.5,0.75)$) {\\usebox\\orgicon};
  %% Text %%
  \\node[left, align=right, black, text width=0.8\\paperwidth, minimum height=3cm, rounded corners,font=\\Huge\\bfseries] at ($(current page.north east)+(-2,-8.5)$)
  {\\@title};
  \\node[left, align=right, black, text width=0.8\\paperwidth, minimum height=2cm, rounded corners, font=\\Large] at ($(current page.north east)+(-2,-11.8)$)
  {\\scshape \\@author};
  \\renewcommand{\\baselinestretch}{0.75}
  \\node[align=center,rounded corners,fill=black!3,text=black,regular polygon,regular polygon sides=6, minimum size=2.5 cm,inner sep=0, font=\\Large\\bfseries ] at ($(current page.west)+(2.5,-4.2)$)
  {\\@date};
  \\end{tikzpicture}
  \\let\\today\\oldtoday
  \\clearpage}
\\makeatother
#+end_src

Now we've got a nice cover page to work with, we just need to use it every now
and then. Adding this to =#+options= feels most appropriate.
Let's have the =coverpage= option accept =auto= as a value and then decide whether
or not a cover page should be used based on the word count --- I'll have this be
the global default. Then we just want to insert a LaTeX snippet tweak the
subtitle format to use the cover page.

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-cover-page 'auto
  "When t, use a cover page by default.
When auto, use a cover page when the document's wordcount exceeds
`org-latex-cover-page-wordcount-threshold'.

Set with #+option: coverpage:{yes,auto,no} in org buffers.")
(defvar org-latex-cover-page-wordcount-threshold 5000
  "Document word count at which a cover page will be used automatically.
This condition is applied when cover page option is set to auto.")
(defvar org-latex-subtitle-coverpage-format "\\\\\\bigskip\n\\LARGE\\mdseries\\itshape\\color{black!80} %s\\par"
  "Variant of `org-latex-subtitle-format' to use with the cover page.")
(defvar org-latex-cover-page-maketitle "
<<latex-cover-page>>
"
  "LaTeX snippet for the preamble that sets \\maketitle to produce a cover page.")

(eval '(cl-pushnew '(:latex-cover-page nil "coverpage" org-latex-cover-page)
                   (org-export-backend-options (org-export-get-backend 'latex))))

(defun org-latex-cover-page-p ()
  "Whether a cover page should be used when exporting this Org file."
  (pcase (or (car
              (delq nil
                    (mapcar
                     (lambda (opt-line)
                       (plist-get (org-export--parse-option-keyword opt-line 'latex) :latex-cover-page))
                     (cdar (org-collect-keywords '("OPTIONS"))))))
             org-latex-cover-page)
    ((or 't 'yes) t)
    ('auto (when (> (count-words (point-min) (point-max)) org-latex-cover-page-wordcount-threshold) t))
    (_ nil)))

(defadvice! org-latex-set-coverpage-subtitle-format-a (contents info)
  "Set the subtitle format when a cover page is being used."
  :before #'org-latex-template
  (when (org-latex-cover-page-p)
    (setf info (plist-put info :latex-subtitle-format org-latex-subtitle-coverpage-format))))

(add-to-list 'org-latex-feature-implementations '(cover-page :snippet org-latex-cover-page-maketitle :order 9) t)
(add-to-list 'org-latex-conditional-features '((org-latex-cover-page-p) . cover-page) t)
#+end_src
**** Condensed lists
LaTeX is generally pretty good by default, but it's /really/ generous with how
much space it puts between list items by default. I'm generally not a fan.

Thankfully this is easy to correct with a small snippet:
#+name: latex-condense-lists
#+begin_src LaTeX
\\let\\olditem\\itemize\\renewcommand{\\itemize}{\\olditem\\setlength{\\itemsep}{-2ex}}
\\let\\oldenum\\enumerate\\renewcommand{\\enumerate}{\\oldenum\\setlength{\\itemsep}{-2ex}}
\\let\\olddesc\\description\\renewcommand{\\description}{\\olddesc\\setlength{\\itemsep}{-2ex}}
#+end_src

Then we can just hook this in with our clever preamble.

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-condense-lists t
  "Reduce the space between list items.")
(defvar org-latex-condensed-lists "
<<latex-condense-lists>>
")

(add-to-list 'org-latex-conditional-features '((and org-latex-condense-lists "^[ \t]*[-+]\\|^[ \t]*[1Aa][.)] ") . condensed-lists) t)
(add-to-list 'org-latex-feature-implementations '(condensed-lists :snippet org-latex-condensed-lists :order 0.7) t)
#+end_src

**** Pretty code blocks

We could just use minted for syntax highlighting --- however, we can do better!
The =engrave-faces= package lets us use Emacs' font-lock for syntax highlighting,
exporting that as LaTeX commands.

#+begin_src emacs-lisp
(setq org-latex-listings 'engraved) ; NOTE non-standard value
#+end_src

Thanks to ~org-latex-conditional-features~ and some copy-paste with the =minted=
entry in ~org-latex-scr-block~ we can easily add this as a recognised
~org-latex-listings~ value.

#+begin_src emacs-lisp :noweb no-export
(defadvice! org-latex-src-block-engraved (orig-fn src-block contents info)
  "Like `org-latex-src-block', but supporting an engraved backend"
  :around #'org-latex-src-block
  (if (eq 'engraved (plist-get info :latex-listings))
      (org-latex-scr-block--engraved src-block contents info)
    (funcall orig-fn src-block contents info)))

(defadvice! org-latex-inline-src-block-engraved (orig-fn inline-src-block contents info)
  "Like `org-latex-inline-src-block', but supporting an engraved backend"
  :around #'org-latex-inline-src-block
  (if (eq 'engraved (plist-get info :latex-listings))
      (org-latex-inline-scr-block--engraved inline-src-block contents info)
    (funcall orig-fn src-block contents info)))

(defvar-local org-export-has-code-p nil)

(defadvice! org-export-expect-no-code (&rest _)
  :before #'org-export-as
  (setq org-export-has-code-p nil))

(defadvice! org-export-register-code (&rest _)
  :after #'org-latex-src-block-engraved
  :after #'org-latex-inline-src-block-engraved
  (setq org-export-has-code-p t))

(setq org-latex-engraved-code-preamble "
<<org-latex-engraved-code-preamble>>
")

(add-to-list 'org-latex-conditional-features '((and org-export-has-code-p "^[ \t]*#\\+begin_src\\|^[ \t]*#\\+BEGIN_SRC\\|src_[A-Za-z]") . engraved-code) t)
(add-to-list 'org-latex-feature-implementations '(engraved-code :requires engraved-code-setup :snippet (engrave-faces-latex-gen-preamble) :order 99) t)
(add-to-list 'org-latex-feature-implementations '(engraved-code-setup :snippet org-latex-engraved-code-preamble :order 98) t)

(defun org-latex-scr-block--engraved (src-block contents info)
  (let* ((lang (org-element-property :language src-block))
         (attributes (org-export-read-attribute :attr_latex src-block))
         (float (plist-get attributes :float))
         (num-start (org-export-get-loc src-block info))
         (retain-labels (org-element-property :retain-labels src-block))
         (caption (org-element-property :caption src-block))
         (caption-above-p (org-latex--caption-above-p src-block info))
         (caption-str (org-latex--caption/label-string src-block info))
         (placement (or (org-unbracket-string "[" "]" (plist-get attributes :placement))
                        (plist-get info :latex-default-figure-position)))
         (float-env
          (cond
           ((string= "multicolumn" float)
            (format "\\begin{listing*}[%s]\n%s%%s\n%s\\end{listing*}"
                    placement
                    (if caption-above-p caption-str "")
                    (if caption-above-p "" caption-str)))
           (caption
            (format "\\begin{listing}[%s]\n%s%%s\n%s\\end{listing}"
                    placement
                    (if caption-above-p caption-str "")
                    (if caption-above-p "" caption-str)))
           ((string= "t" float)
            (concat (format "\\begin{listing}[%s]\n"
                            placement)
                    "%s\n\\end{listing}"))
           (t "%s")))
         (options (plist-get info :latex-minted-options))
         (content-buffer
          (with-temp-buffer
            (insert
             (let* ((code-info (org-export-unravel-code src-block))
                    (max-width
                     (apply 'max
                            (mapcar 'length
                                    (org-split-string (car code-info)
                                                      "\n")))))
               (org-export-format-code
                (car code-info)
                (lambda (loc _num ref)
                  (concat
                   loc
                   (when ref
                     ;; Ensure references are flushed to the right,
                     ;; separated with 6 spaces from the widest line
                     ;; of code.
                     (concat (make-string (+ (- max-width (length loc)) 6)
                                          ?\s)
                             (format "(%s)" ref)))))
                nil (and retain-labels (cdr code-info)))))
            (funcall (org-src-get-lang-mode lang))
            (engrave-faces-latex-buffer)))
         (content
          (with-current-buffer content-buffer
            (buffer-string)))
         (body
          (format
           "\\begin{Code}\n\\begin{Verbatim}[%s]\n%s\\end{Verbatim}\n\\end{Code}"
           ;; Options.
           (concat
            (org-latex--make-option-string
             (if (or (not num-start) (assoc "linenos" options))
                 options
               (append
                `(("linenos")
                  ("firstnumber" ,(number-to-string (1+ num-start))))
                options)))
            (let ((local-options (plist-get attributes :options)))
              (and local-options (concat "," local-options))))
           content)))
    (kill-buffer content-buffer)
    ;; Return value.
    (format float-env body)))

(defun org-latex-inline-scr-block--engraved (inline-src-block _contents info)
  (let ((options (org-latex--make-option-string
                  (plist-get info :latex-minted-options)))
        code-buffer code)
    (setq code-buffer
          (with-temp-buffer
            (insert (org-element-property :value inline-src-block))
            (funcall (org-src-get-lang-mode
                      (org-element-property :language inline-src-block)))
            (engrave-faces-latex-buffer)))
    (setq code (with-current-buffer code-buffer
                 (buffer-string)))
    (kill-buffer code-buffer)
    (format "\\Verb%s{%s}"
            (if (string= options "") ""
              (format "[%s]" options))
            code)))
#+end_src

Whenever this is used, in order for it to actually work (and look a little
better) we add bit to the preamble:

#+name: org-latex-engraved-code-preamble
#+begin_src LaTeX
\\usepackage{fvextra}
\\fvset{
  commandchars=\\\\\\{\\},
  highlightcolor=white!95!black!80!blue,
  breaklines=true,
  breaksymbol=\\color{white!60!black}\\tiny\\ensuremath{\\hookrightarrow}}
\\renewcommand\\theFancyVerbLine{\\footnotesize\\color{black!40!white}\\arabic{FancyVerbLine}}

\\definecolor{codebackground}{HTML}{f7f7f7}
\\definecolor{codeborder}{HTML}{f0f0f0}

% TODO have code boxes keep line vertical alignment
\\usepackage[breakable,xparse]{tcolorbox}
\\DeclareTColorBox[]{Code}{o}%
{colback=codebackground, colframe=codeborder,
  fontupper=\\footnotesize,
  colupper=EFD,
  IfNoValueTF={#1}%
  {boxsep=2pt, arc=2.5pt, outer arc=2.5pt,
    boxrule=0.5pt, left=2pt}%
  {boxsep=2.5pt, arc=0pt, outer arc=0pt,
    boxrule=0pt, leftrule=1.5pt, left=0.5pt},
  right=2pt, top=1pt, bottom=0.5pt,
  breakable}
#+end_src

At some point it would be nice to make the box colours easily customisable. At
the moment it's fairly easy to change the syntax highlighting colours with
src_elisp{(setq engrave-faces-preset-styles (engrave-faces-generate-preset))},
but perhaps a toggle which specifies whether to use the default values, the
current theme, or any named theme could be a good idea. It should also possible
to set the box background dynamically to match. The named theme could work by
looking for a style definition with a certain name in a cache dir, and then
switching to that theme and producing (and saving) the style definition if it
doesn't exist.

Now let's have the example block be styled similarly.
#+begin_src emacs-lisp
(defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
  "Like `org-latex-example-block', but supporting an engraved backend"
  :around #'org-latex-example-block
  (let ((output-block (funcall orig-fn example-block contents info)))
    (if (eq 'engraved (plist-get info :latex-listings))
        (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
      output-block)))
#+end_src

In addition to the vastly superior visual output, this should also be much
faster to compile for code-heavy documents (like this config).

Performing a little benchmark with this document, I find that this is indeed the
case.

| LaTeX syntax highlighting backend | Compile time | Overhead | Overhead ratio |
|-----------------------------------+--------------+----------+----------------|
| verbatim                          | 12 s         | 0        |            0.0 |
| lstlistings                       | 15 s         | 3 s      |            0.2 |
| Engrave                           | 34 s         | 22 s     |            1.8 |
| Pygments (Minted)                 | 184 s        | 172 s    |           14.3 |
#+TBLFM: $3=$2-@2$2::$4=$3 / @2$2;%.1f

Treating the verbatim (no syntax highlighting) result as a baseline; this
rudimentary test suggest that =engrave-faces= is around eight times faster than
=pygments=, and takes three times as long as no syntax highlighting (verbatim).

**** Remove non-ascii chars

When using ~pdflatex~, almost non-ascii characters are generally problematic, and
don't appear in the pdf. It's preferable to see that there was /some/ character
which wasn't displayed as opposed to nothing.

We check every non-ascii character to make sure it's not a character encoded by
the =inputenc= packages when loaded with the =utf8= option. Finally, we see if we
have our own LaTeX conversion we can apply and if there is none we replace the
non-ascii char with =¿=.

No to make sure we only remove characters that can't be displayed, we check
=/usr/share/texmf/tex/latex/base/utf8enc.dfu=.

We just need to make sure this is appended to the list of filter functions,
since we want to let emoji processing occur first.

#+begin_src emacs-lisp
(defvar +org-pdflatex-inputenc-encoded-chars
  "[[:ascii:]\u00A0-\u01F0\u0218-\u021BȲȳȷˆˇ˜˘˙˛˝\u0400-\u04FFḂḃẞ\u200C\u2010-\u201E†‡•…‰‱‹›※‽⁄⁎⁒₡₤₦₩₫€₱℃№℗℞℠™Ω℧℮←↑→↓〈〉␢␣◦◯♪⟨⟩Ḡḡ\uFB00-\uFB06]")

(defun +org-latex-replace-non-ascii-chars (text backend info)
  "Replace non-ascii chars with \\char\"XYZ forms."
  (when (and (org-export-derived-backend-p backend 'latex)
             (string= (plist-get info :latex-compiler) "pdflatex"))
    (replace-regexp-in-string "[^[:ascii:]]"
                              (lambda (nonascii)
                                (if (string-match-p +org-pdflatex-inputenc-encoded-chars nonascii) nonascii
                                  (or (cdr (assoc nonascii +org-latex-non-ascii-char-substitutions)) "¿")))
                              text)))

(add-to-list 'org-export-filter-final-output-functions #'+org-latex-replace-non-ascii-chars t)
#+end_src

Now, there are some symbols that aren't included in =inputenc=, but we should be
able to handle anyway. For them we define a table of LaTeX translations

#+name: latex-non-ascii-char-substitutions
| Character | LaTeX |
|-----------+-------|
| ɑ         | \(\alpha\) |
| β         | \(\beta\) |
| γ         | \(\gamma\) |
| δ         | \(\delta\) |
| ε         | \(\epsilon\) |
| ϵ         | \(\varepsilon\) |
| ζ         | \(\zeta\) |
| η         | \(\eta\) |
| θ         | \(\theta\) |
| ϑ         | \(\vartheta\) |
| ι         | \(\iota\) |
| κ         | \(\kappa\) |
| λ         | \(\lambda\) |
| μ         | \(\mu\) |
| ν         | \(\nu\) |
| ξ         | \(\xi\) |
| π         | \(\pi\) |
| ϖ         | \(\varpi\) |
| ρ         | \(\rho\) |
| ϱ         | \(\varrho\) |
| σ         | \(\sigma\) |
| ς         | \(\varsigma\) |
| τ         | \(\tau\) |
| υ         | \(\upsilon\) |
| ϕ         | \(\phi\) |
| φ         | \(\varphi\) |
| ψ         | \(\psi\) |
| ω         | \(\omega\) |
| Γ         | \(\Gamma\) |
| Δ         | \(\Delta\) |
| Θ         | \(\Theta\) |
| Λ         | \(\Lambda\) |
| Ξ         | \(\Xi\) |
| Π         | \(\Pi\) |
| Σ         | \(\Sigma\) |
| Υ         | \(\Upsilon\) |
| Φ         | \(\Phi\) |
| Ψ         | \(\Psi\) |
| Ω         | \(\Omega\) |
| א         | \(\aleph\) |
| ב         | \(\beth\) |
| ד         | \(\daleth\) |
| ג         | \(\gimel\) |

#+name: gen-latex-non-ascii-char-substitutions
#+begin_src emacs-lisp :noweb-ref none :var latex-non-ascii-char-substitutions=latex-non-ascii-char-substitutions
(replace-regexp-in-string
 " '((" "\n   '(("
 (replace-regexp-in-string
  ") (" ")\n     ("
  (prin1-to-string
   `(defvar +org-latex-non-ascii-char-substitutions
      ',(mapcar
         (lambda (entry)
           (cons (car entry) (replace-regexp-in-string "\\\\" "\\\\\\\\" (cadr entry))))
         latex-non-ascii-char-substitutions)))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<gen-latex-non-ascii-char-substitutions()>>
#+end_src

**** Extra special strings
LaTeX already recognises =---= and =--= as em/en-dashes, =\-= as a shy hyphen, and the
conversion of =...= to =\ldots{}= is hardcoded into ~org-latex-plain-text~ (unlike
~org-html-plain-text~).

I'd quite like to also recognise =->= and =<-=, so let's set come up with some advice.

#+begin_src emacs-lisp
(defvar org-latex-extra-special-string-regexps
  '(("->" . "\\\\textrightarrow{}")
    ("<-" . "\\\\textleftarrow{}")))

(defun org-latex-convert-extra-special-strings (string)
  "Convert special characters in STRING to LaTeX."
  (dolist (a org-latex-extra-special-string-regexps string)
    (let ((re (car a))
          (rpl (cdr a)))
      (setq string (replace-regexp-in-string re rpl string t)))))

(defadvice! org-latex-plain-text-extra-special-a (orig-fn text info)
  "Make `org-latex-plain-text' handle some extra special strings."
  :around #'org-latex-plain-text
  (let ((output (funcall orig-fn text info)))
    (when (plist-get info :with-special-strings)
      (setq output (org-latex-convert-extra-special-strings output)))
    output))
#+end_src

**** Support images from URLs
You can link to remote images easily, and they work nicely with HTML-based
exports. However, LaTeX can only include local files, and so the current
behaviour of =org-latex-link= is just to insert a URL to the image.

We can do better than that by downloading the image to a predictable location,
and using that. By making the filename predictable as opposed to just another
tempfile, this can provide a caching mechanism.

#+begin_src emacs-lisp
(defadvice! +org-latex-link (orig-fn link desc info)
  "Acts as `org-latex-link', but supports remote images."
  :around #'org-latex-link
  (setq o-link link
        o-desc desc
        o-info info)
  (if (and (member (plist-get (cadr link) :type) '("http" "https"))
           (member (file-name-extension (plist-get (cadr link) :path))
                   '("png" "jpg" "jpeg" "pdf" "svg")))
      (org-latex-link--remote link desc info)
    (funcall orig-fn link desc info)))

(defun org-latex-link--remote (link _desc info)
  (let* ((url (plist-get (cadr link) :raw-link))
         (ext (file-name-extension url))
         (target (format "%s%s.%s"
                         (temporary-file-directory)
                         (replace-regexp-in-string "[./]" "-"
                                                   (file-name-sans-extension (substring (plist-get (cadr link) :path) 2)))
                         ext)))
    (unless (file-exists-p target)
      (url-copy-file url target))
    (setcdr link (--> (cadr link)
                   (plist-put it :type "file")
                   (plist-put it :path target)
                   (plist-put it :raw-link (concat "file:" target))
                   (list it)))
    (concat "% fetched from " url "\n"
            (org-latex--inline-image link info))))
#+end_src
**** Chameleon --- aka. match theme
Once the idea of having the look of the LaTeX document produced match the
current Emacs theme, I was enraptured. The result is the pseudo-class ~chameleon~.
#+begin_src emacs-lisp
(after! ox
  (defvar ox-chameleon-base-class "scr-article"
    "The base class that chameleon builds on")

  (defvar ox-chameleon--p nil
    "Used to indicate whether the current export is trying to blend in. Set just before being accessed.")

  ;; (setf (alist-get :filter-latex-class
  ;;                  (org-export-backend-filters
  ;;                   (org-export-get-backend 'latex)))
  ;;       'ox-chameleon-latex-class-detector-filter)

  ;; (defun ox-chameleon-latex-class-detector-filter (info backend)
  ;;   ""
  ;;   (setq ox-chameleon--p (when (equal (plist-get info :latex-class)
  ;;                                      "chameleon")
  ;;                           (plist-put info :latex-class ox-chameleon-base-class)
  ;;                           t)))

  ;; TODO make this less hacky. One ideas was as follows
  ;; (map-put (org-export-backend-filters (org-export-get-backend 'latex))
  ;;           :filter-latex-class 'ox-chameleon-latex-class-detector-filter))
  ;; Never seemed to execute though
  (defadvice! ox-chameleon-org-latex-detect (orig-fun info)
    :around #'org-export-install-filters
    (setq ox-chameleon--p (when (equal (plist-get info :latex-class)
                                       "chameleon")
                            (plist-put info :latex-class ox-chameleon-base-class)
                            t))
    (funcall orig-fun info))

  (defadvice! ox-chameleon-org-latex-export (orig-fn info &optional template snippet?)
    :around #'org-latex-make-preamble
    (if ox-chameleon--p
        (let ((engrave-faces-preset-styles (engrave-faces-generate-preset)))
          (concat (funcall orig-fn info template snippet?)
                  (ox-chameleon-generate-colourings)))
      (funcall orig-fn info template snippet?)))

  (defun ox-chameleon-generate-colourings ()
    (apply #'format
           "%% make document follow Emacs theme
\\definecolor{bg}{HTML}{%s}
\\definecolor{fg}{HTML}{%s}

\\definecolor{red}{HTML}{%s}
\\definecolor{orange}{HTML}{%s}
\\definecolor{green}{HTML}{%s}
\\definecolor{teal}{HTML}{%s}
\\definecolor{yellow}{HTML}{%s}
\\definecolor{blue}{HTML}{%s}
\\definecolor{dark-blue}{HTML}{%s}
\\definecolor{magenta}{HTML}{%s}
\\definecolor{violet}{HTML}{%s}
\\definecolor{cyan}{HTML}{%s}
\\definecolor{dark-cyan}{HTML}{%s}

\\definecolor{documentTitle}{HTML}{%s}
\\definecolor{documentInfo}{HTML}{%s}
\\definecolor{level1}{HTML}{%s}
\\definecolor{level2}{HTML}{%s}
\\definecolor{level3}{HTML}{%s}
\\definecolor{level4}{HTML}{%s}
\\definecolor{level5}{HTML}{%s}
\\definecolor{level6}{HTML}{%s}
\\definecolor{level7}{HTML}{%s}
\\definecolor{level8}{HTML}{%s}

\\definecolor{link}{HTML}{%s}
\\definecolor{cite}{HTML}{%s}
\\definecolor{itemlabel}{HTML}{%s}
\\definecolor{code}{HTML}{%s}
\\definecolor{verbatim}{HTML}{%s}

\\definecolor{codebackground}{HTML}{%s}
\\colorlet{EFD}{fg}
\\definecolor{codeborder}{HTML}{%s}

\\pagecolor{bg}
\\color{fg}

\\addtokomafont{title}{\\color{documentTitle}}
\\addtokomafont{author}{\\color{documentInfo}}
\\addtokomafont{date}{\\color{documentInfo}}
\\addtokomafont{section}{\\color{level1}}
\\newkomafont{sectionprefix}{\\color{level1}}
\\addtokomafont{subsection}{\\color{level2}}
\\newkomafont{subsectionprefix}{\\color{level2}}
\\addtokomafont{subsubsection}{\\color{level3}}
\\newkomafont{subsubsectionprefix}{\\color{level3}}
\\addtokomafont{paragraph}{\\color{level4}}
\\newkomafont{paragraphprefix}{\\color{level4}}
\\addtokomafont{subparagraph}{\\color{level5}}
\\newkomafont{subparagraphprefix}{\\color{level5}}

\\renewcommand{\\labelitemi}{\\textcolor{itemlabel}{\\textbullet}}
\\renewcommand{\\labelitemii}{\\textcolor{itemlabel}{\\normalfont\\bfseries \\textendash}}
\\renewcommand{\\labelitemiii}{\\textcolor{itemlabel}{\\textasteriskcentered}}
\\renewcommand{\\labelitemiv}{\\textcolor{itemlabel}{\\textperiodcentered}}

\\renewcommand{\\labelenumi}{\\textcolor{itemlabel}{\\theenumi.}}
\\renewcommand{\\labelenumii}{\\textcolor{itemlabel}{(\\theenumii)}}
\\renewcommand{\\labelenumiii}{\\textcolor{itemlabel}{\\theenumiii.}}
\\renewcommand{\\labelenumiv}{\\textcolor{itemlabel}{\\theenumiv.}}

\\DeclareTextFontCommand{\\texttt}{\\color{code}\\ttfamily}
\\makeatletter
\\def\\verbatim@font{\\color{verbatim}\\normalfont\\ttfamily}
\\makeatother
%% end customisations
"
           (mapcar (doom-rpartial #'substring 1)
                   (list
                    (face-attribute 'solaire-default-face :background)
                    (face-attribute 'default :foreground)
                    ;;
                    (doom-color 'red)
                    (doom-color 'orange)
                    (doom-color 'green)
                    (doom-color 'teal)
                    (doom-color 'yellow)
                    (doom-color 'blue)
                    (doom-color 'dark-blue)
                    (doom-color 'magenta)
                    (doom-color 'violet)
                    (doom-color 'cyan)
                    (doom-color 'dark-cyan)
                    ;;
                    (face-attribute 'org-document-title :foreground)
                    (face-attribute 'org-document-info :foreground)
                    (face-attribute 'outline-1 :foreground)
                    (face-attribute 'outline-2 :foreground)
                    (face-attribute 'outline-3 :foreground)
                    (face-attribute 'outline-4 :foreground)
                    (face-attribute 'outline-5 :foreground)
                    (face-attribute 'outline-6 :foreground)
                    (face-attribute 'outline-7 :foreground)
                    (face-attribute 'outline-8 :foreground)
                    ;;
                    (face-attribute 'link :foreground)
                    (or (face-attribute 'org-ref-cite-face :foreground) (doom-color 'yellow))
                    (face-attribute 'org-list-dt :foreground)
                    (face-attribute 'org-code :foreground)
                    (face-attribute 'org-verbatim :foreground)
                    ;;
                    (face-attribute 'default :background)
                    (doom-blend (face-attribute 'default :background)
                                (face-attribute 'default :foreground)
                                0.95))))))
#+end_src
**** Make verbatim different to code
Since have just gone to so much effort above let's make the most of it by making
=verbatim= use ~verb~ instead of ~protectedtexttt~ (default).

This gives the same advantages as mentioned in the [[*Make verbatim different to code][HTML export section]].

#+begin_src emacs-lisp
(setq org-latex-text-markup-alist
      '((bold . "\\textbf{%s}")
        (code . protectedtexttt)
        (italic . "\\emph{%s}")
        (strike-through . "\\sout{%s}")
        (underline . "\\uline{%s}")
        (verbatim . verb)))
#+end_src
**** No AucTeX please
For some reason, the way that ~org-export-to-file~ works, I find that =latex-mode=
is called on the produced buffer prior to saving. This has two undesirable
side-effects:
+ I get unwanted warnings from AuxTeX
+ A spurious =.auctex-auto= folder is produced.

There are a few ways I could try to avoid this, but the most obvious to me is
locally binding ~auto-mode-alist~ to ~nil~.
#+begin_src emacs-lisp
(defadvice! no-auto-mode-alist (orig-fn &rest args)
  "Wrap ORIG-FN in a let-binding that sets `auto-mode-alist' to nil."
  :around #'org-export-to-file
  (let ((auto-mode-alist nil))
    (apply orig-fn args)))
#+end_src
**** Check for required packages

For how I've setup Org's LaTeX export, the following packages are needed:
#+name: org-latex-required-packages-list
+ adjustbox
+ arev
+ amsmath
+ booktabs
+ cancel
+ capt-of
+ caption
+ cleveref
+ embedall
+ fourier
+ fvextra
+ gillius
+ graphicx
+ hyperref
+ mathalpha
+ mathtools
+ microtype
+ pdfx
+ pifont
+ preview
+ siunitx
+ soul
+ subcaption
+ svg
+ tcolorbox
+ xcolor
+ xparse

Then for the various fontsets:
#+name: org-latex-font-packages-list
+ Alegreya
+ biolinum
+ FiraMono
+ FiraSans
+ kpfonts
+ libertine
+ newpxmath
+ newpxtext
+ newtxmath
+ newtxtext
+ newtxsf
+ noto
+ plex-mono
+ plex-sans
+ plex-serif
+ sourcecodepro
+ sourcesanspro
+ sourceserifpro

We can write a function which will check for each of these packages with
=kpsewhich=, and then if any of them are missing we'll inject some advice into the
generated config that gets a list of missing packages and warns us every time we
export to a PDF.

#+name: org-missing-latex-packages
#+begin_src emacs-lisp :noweb-ref none :var org-latex-required-packages-list=org-latex-required-packages-list :var org-latex-font-packages-list=org-latex-font-packages-list
(setq org-required-latex-packages (append (mapcar #'car org-latex-required-packages-list)
                                          (mapcar #'car org-latex-font-packages-list)))

(defun check-for-latex-packages (packages)
  (delq nil (mapcar (lambda (package)
                      (unless
                          (= 0 (shell-command (format "kpsewhich %s.sty" package)))
                        package))
                    packages)))

(if-let ((missing-pkgs (check-for-latex-packages org-required-latex-packages)))
    (concat
     (pp-to-string `(setq org-required-latex-packages ',org-required-latex-packages))
     (message ";; Detected missing LaTeX packages: %s\n" (mapconcat #'identity missing-pkgs ", "))
     (pp-to-string
      '(defun check-for-latex-packages (packages)
         (delq nil (mapcar (lambda (package)
                             (unless
                                 (= 0 (shell-command (format "kpsewhich %s.sty" package)))
                               package))
                           packages))))
     (pp-to-string
      '(defun +org-warn-about-missing-latex-packages (&rest _)
         (message "Checking for missing LaTeX packages...")
         (sleep-for 0.4)
         (if-let (missing-pkgs (check-for-latex-packages org-required-latex-packages))
             (message "%s You are missing the following LaTeX packages: %s."
                      (propertize "Warning!" 'face '(bold warning))
                      (mapconcat (lambda (pkg) (propertize pkg 'face 'font-lock-variable-name-face))
                                 missing-pkgs
                                 ", "))
           (message "%s You have all the required LaTeX packages. Run %s to make this message go away."
                    (propertize "Success!" 'face '(bold success))
                    (propertize "doom sync" 'face 'font-lock-keyword-face))
           (advice-remove 'org-latex-export-to-pdf #'+org-warn-about-missing-latex-packages))
         (sleep-for 1)))
     (pp-to-string
      '(advice-add 'org-latex-export-to-pdf :before #'+org-warn-about-missing-latex-packages)))
  ";; No missing LaTeX packags detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<org-missing-latex-packages()>>
#+end_src
*** Beamer Export
It's nice to use a different theme
#+begin_src emacs-lisp
(setq org-beamer-theme "[progressbar=foot]metropolis")
#+end_src

#+begin_src emacs-lisp
(defun org-beamer-p (info)
  (eq 'beamer (and (plist-get info :back-end) (org-export-backend-name (plist-get info :back-end)))))

(add-to-list 'org-latex-conditional-features '(org-beamer-p . beamer) t)
(add-to-list 'org-latex-feature-implementations '(beamer :requires .missing-koma :prevents (italic-quotes condensed-lists)) t)
(add-to-list 'org-latex-feature-implementations '(.missing-koma :snippet "\\usepackage{scrextend}" :order 3) t)
#+end_src

And I think that it's natural to divide a presentation into sections, e.g.
Introduction, Overview... so let's set bump up the headline level that becomes a
frame from ~1~ to ~2~.
#+begin_src emacs-lisp
(setq org-beamer-frame-level 2)
#+end_src
*** ASCII export

To start with, why settle for ASCII when UTF-8 exists?
#+begin_src emacs-lisp
(setq org-ascii-charset 'utf-8)
#+end_src

The ASCII export is generally fairly nice. I think the main aspect that could
benefit from improvement is the appearance of LaTeX fragments. There's a nice
utility we can use to create unicode representation, which are much nicer.
It's called ~latex2text~, and it's part of the =pylatexenc= package, and it's [[https://repology.org/project/python:pylatexenc/versions][not
really packaged]]. So, we'll resort to installing it with =pip=.

#+begin_src shell :tangle (if (executable-find "latex2text") "no" "setup.sh")
sudo python3 -m pip install pylatexenc
#+end_src

With that installed, we can override the src_elisp{(org-ascii-latex-fragment)} and
src_elisp{(org-ascii-latex-environment)} functions, which are conveniently very
slim --- just extracting the content, and indenting. We'll only do something
different when =utf-8= is set.

#+begin_src emacs-lisp :noweb-ref none :tangle (if (executable-find "latex2text") "yes" "no")
(after! ox-ascii
  (defvar org-ascii-convert-latex t
    "Use latex2text to convert LaTeX elements to unicode.")

  (defadvice! org-ascii-latex-environment-unicode-a (latex-environment _contents info)
    "Transcode a LATEX-ENVIRONMENT element from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
    :override #'org-ascii-latex-environment
    (when (plist-get info :with-latex)
      (org-ascii--justify-element
       (org-remove-indentation
        (let* ((latex (org-element-property :value latex-environment))
               (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                             org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
          (if (= (car unicode) 0) ; utf-8 set, and sucessfully ran latex2text
              (cdr unicode) latex)))
       latex-environment info)))

  (defadvice! org-ascii-latex-fragment-unicode-a (latex-fragment _contents info)
    "Transcode a LATEX-FRAGMENT object from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
    :override #'org-ascii-latex-fragment
    (when (plist-get info :with-latex)
      (let* ((latex (org-element-property :value latex-fragment))
             (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                           org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
        (if (= (car unicode) 0) ; utf-8 set, and sucessfully ran latex2text
            (cdr unicode) latex)))))
#+end_src

*** Markdown Export
When I want to paste exported markdown somewhere (for example when using [[Emacs Everywhere][Emacs
Everywhere]]), it can be preferable to have unicode characters for =---= etc. instead
of =&#x2014;=.

To accomplish this, we just need to locally rebind the alist which provides
these substitution.

#+begin_src emacs-lisp
(defadvice! org-md-plain-text-unicode-a (orig-fn text info)
  "Locally rebind `org-html-special-string-regexps'"
  :around #'org-md-plain-text
  (let ((org-html-special-string-regexps
         '(("\\\\-" . "-")
           ("---\\([^-]\\|$\\)" . "—\\1")
           ("--\\([^-]\\|$\\)" . "–\\1")
           ("\\.\\.\\." . "…")
           ("->" . "→")
           ("<-" . "←"))))
    (funcall orig-fn text (plist-put info :with-smart-quotes nil))))
#+end_src

In the future, I may want to check =info= to only have this active when =ox-gfm= is
being used.

Another worthwhile consideration is LaTeX formatting. It seems most Markdown
parsers are fixated on TeX-style syntax (=$= and =$$=). As unfortunate as this is,
it's probably best to accommodate them, for the sake of decent rendering.

=ox-md= doesn't provide any transcoders for this, so we'll have to whip up our own
and push them onto the =md= transcoders alist.

#+begin_src emacs-lisp
(after! ox-md
  (defun org-md-latex-fragment (latex-fragment _contents info)
    "Transcode a LATEX-FRAGMENT object from Org to Markdown."
    (let ((frag (org-element-property :value latex-fragment)))
      (cond
       ((string-match-p "^\\\\(" frag)
        (concat "$" (substring frag 2 -2) "$"))
       ((string-match-p "^\\\\\\[" frag)
        (concat "$$" (substring frag 2 -2) "$$"))
       (t (message "unrecognised fragment: %s" frag)
          frag))))

  (defun org-md-latex-environment (latex-environment contents info)
    "Transcode a LATEX-ENVIRONMENT object from Org to Markdown."
    (concat "$$\n"
            (org-html-latex-environment latex-environment contents info)
            "$$\n"))

  (defun org-utf8-entity (entity _contents _info)
    "Transcode an ENTITY object from Org to utf-8.
CONTENTS are the definition itself.  INFO is a plist holding
contextual information."
    (org-element-property :utf-8 entity))

  ;; We can't let this be immediately parsed and evaluated,
  ;; because eager macro-expansion tries to call as-of-yet
  ;; undefined functions.
  ;; NOTE in the near future this shouldn't be required
  (eval
   '(dolist (extra-transcoder
             '((latex-fragment . org-md-latex-fragment)
               (latex-environment . org-md-latex-environment)
               (entity . org-utf8-entity)))
      (unless (member extra-transcoder (org-export-backend-transcoders
                                        (org-export-get-backend 'md)))
        (push extra-transcoder (org-export-backend-transcoders
                                (org-export-get-backend 'md)))))))
#+end_src

*** Babel
Doom lazy-loads babel languages, with is lovely.
It also pulls in [[https://github.com/astahlman/ob-async][ob-async]], which is nice, but it would be even better if it was
used by default.

There are two caveats to =ob-async=:
1. It does not support =:session=
   + So, we don't want =:async= used when =:session= is set
2. It adds a fixed delay to execution
   + This is undesirable in a number of cases, for example it's generally
     unwanted with =emacs-lisp= code
   + As such, I also introduce a async language blacklist to control when it's
     automatically enabled

Due to the nuance in the desired behaviour, instead of just adding =:async= to
~org-babel-default-header-args~, I advice ~org-babel-get-src-block-info~ to add
=:async= intelligently. As an escape hatch, it also recognises =:sync= as an
indication that =:async= should not be added.

I did originally have this enabled for everything except for =emacs-lisp= and
=LaTeX= (there were weird issues), but this added  a ~3s "startup" cost to every
src block evaluation, which was a bit of a pain. Since =:async= can be added
easily with =#+properties=, I've turned this behaviour from a blacklist to a
whitelist.

#+begin_src emacs-lisp
(add-transient-hook! #'org-babel-execute-src-block
  (require 'ob-async))

(defvar org-babel-auto-async-languages '()
  "Babel languages which should be executed asyncronously by default.")

(defadvice! org-babel-get-src-block-info-eager-async-a (orig-fn &optional light datum)
  "Eagarly add an :async parameter to the src information, unless it seems problematic.
This only acts o languages in `org-babel-auto-async-languages'.
Not added when either:
+ session is not \"none\"
+ :sync is set"
  :around #'org-babel-get-src-block-info
  (let ((result (funcall orig-fn light datum)))
    (when (and (string= "none" (cdr (assoc :session (caddr result))))
               (member (car result) org-babel-auto-async-languages)
               (not (assoc :async (caddr result))) ; don't duplicate
               (not (assoc :sync (caddr result))))
      (push '(:async) (caddr result)))
    result))
#+end_src
** LaTeX
*** To-be-implemented ideas
- Paste image from clipboard
  + Determine first folder in ~graphicspath~ if applicable
  + Ask for file name
  + Use ~xclip~ to save file to graphics folder, or current directory (whichever applies)
  #+begin_src shell :eval no :tangle no
command -v xclip >/dev/null 2>&1 || { echo >&1 "no xclip"; exit 1; }

if
    xclip -selection clipboard -target image/png -o >/dev/null 2>&1
then
    xclip -selection clipboard -target image/png -o >$1 2>/dev/null
    echo $1
else
    echo "no image"
fi
  #+end_src
  + Insert figure, with filled in details as a result (activate =yasnippet= with
    filename as variable maybe?)
*** Compilation
#+begin_src emacs-lisp
(setq TeX-save-query nil
      TeX-show-compilation t
      TeX-command-extra-options "-shell-escape")
(after! latex
  (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t)))
#+end_src

For viewing the PDF, I rather like the pdf-tools viewer. While auctex is trying
to be nice in recognising that I have some PDF viewing apps installed, I'd
rather not have it default to using them, so let's re-order the preferences.
#+begin_src emacs-lisp
(setq +latex-viewers '(pdf-tools evince zathura okular skim sumatrapdf))
#+end_src
*** Snippet helpers
**** Template
For use in the new-file template, let's set out a nice preamble we may want to use.
#+name: latex-nice-preamble
#+begin_src latex :tangle no
\\usepackage[pdfa,unicode=true,hidelinks]{hyperref}

\\usepackage[dvipsnames,svgnames,table,hyperref]{xcolor}
\\renewcommand{\\UrlFont}{\\ttfamily\\small}

\\usepackage[a-2b]{pdfx} % why not be archival

\\usepackage[T1]{fontenc}
\\usepackage[osf]{newpxtext}  % Palatino
\\usepackage{gillius}
\\usepackage[scale=0.9]{sourcecodepro}

\\usepackage[varbb]{newpxmath}
\\usepackage{mathtools}
\\usepackage{amssymb}

\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}
% microtype makes text look nicer

\\usepackage{graphicx} % include graphics

\\usepackage{booktabs} % nice table rules
#+end_src
Then let's bind the content to a function, and define some nice helpers.
#+begin_src emacs-lisp :noweb no-export
(setq tec/yas-latex-template-preamble "
<<latex-nice-preamble>>
")

(defun tec/yas-latex-get-class-choice ()
  "Prompt user for LaTeX class choice"
  (setq tec/yas-latex-class-choice (consult--read "Select document class: " '("article" "scrartcl" "bmc") :def "bmc")))

(defun tec/yas-latex-preamble-if ()
  "Based on class choice prompt for insertion of default preamble"
  (if (equal tec/yas-latex-class-choice "bmc") 'nil
    (eq (read-char-choice "Include default preamble? [Type y/n]" '(?y ?n)) ?y)))
#+end_src
**** Deliminators
#+begin_src emacs-lisp
(after! tex
  (defvar tec/tex-last-delim-char nil
    "Last open delim expanded in a tex document")
  (defvar tec/tex-delim-dot-second t
    "When the `tec/tex-last-delim-char' is . a second character (this) is prompted for")
  (defun tec/get-open-delim-char ()
    "Exclusivly read next char to tec/tex-last-delim-char"
    (setq tec/tex-delim-dot-second nil)
    (setq tec/tex-last-delim-char (read-char-exclusive "Opening deliminator, recognises: 9 ( [ { < | ."))
    (when (eql ?. tec/tex-last-delim-char)
      (setq tec/tex-delim-dot-second (read-char-exclusive "Other deliminator, recognises: 0 9 (  ) [ ] { } < > |"))))
  (defun tec/tex-open-delim-from-char (&optional open-char)
    "Find the associated opening delim as string"
    (unless open-char (setq open-char (if (eql ?. tec/tex-last-delim-char)
                                          tec/tex-delim-dot-second
                                        tec/tex-last-delim-char)))
    (pcase open-char
      (?\( "(")
      (?9  "(")
      (?\[ "[")
      (?\{ "\\{")
      (?<  "<")
      (?|  (if tec/tex-delim-dot-second "." "|"))
      (_   ".")))
  (defun tec/tex-close-delim-from-char (&optional open-char)
    "Find the associated closing delim as string"
    (if tec/tex-delim-dot-second
        (pcase tec/tex-delim-dot-second
          (?\) ")")
          (?0  ")")
          (?\] "]")
          (?\} "\\}")
          (?\> ">")
          (?|  "|")
          (_   "."))
      (pcase (or open-char tec/tex-last-delim-char)
        (?\( ")")
        (?9  ")")
        (?\[ "]")
        (?\{ "\\}")
        (?<  ">")
        (?\) ")")
        (?0  ")")
        (?\] "]")
        (?\} "\\}")
        (?\> ">")
        (?|  "|")
        (_   "."))))
  (defun tec/tex-next-char-smart-close-delim (&optional open-char)
    (and (bound-and-true-p smartparens-mode)
         (eql (char-after) (pcase (or open-char tec/tex-last-delim-char)
                             (?\( ?\))
                             (?\[ ?\])
                             (?{ ?})
                             (?< ?>)))))
  (defun tec/tex-delim-yas-expand (&optional open-char)
    (yas-expand-snippet (yas-lookup-snippet "_deliminators" 'latex-mode) (point) (+ (point) (if (tec/tex-next-char-smart-close-delim open-char) 2 1)))))
#+end_src
*** Editor visuals
Once again, /all hail mixed pitch mode!/
#+begin_src emacs-lisp
(add-hook 'LaTeX-mode-hook #'mixed-pitch-mode)
#+end_src

Let's enhance ~TeX-fold-math~ a bit
#+begin_src emacs-lisp
(after! latex
  (setcar (assoc "⋆" LaTeX-fold-math-spec-list) "★")) ;; make \star bigger

(setq TeX-fold-math-spec-list
      `(;; missing/better symbols
        ("≤" ("le"))
        ("≥" ("ge"))
        ("≠" ("ne"))
        ;; convenience shorts -- these don't work nicely ATM
        ;; ("‹" ("left"))
        ;; ("›" ("right"))
        ;; private macros
        ("ℝ" ("RR"))
        ("ℕ" ("NN"))
        ("ℤ" ("ZZ"))
        ("ℚ" ("QQ"))
        ("ℂ" ("CC"))
        ("ℙ" ("PP"))
        ("ℍ" ("HH"))
        ("𝔼" ("EE"))
        ("𝑑" ("dd"))
        ;; known commands
        ("" ("phantom"))
        (,(lambda (num den) (if (and (TeX-string-single-token-p num) (TeX-string-single-token-p den))
                                (concat num "／" den)
                              (concat "❪" num "／" den "❫"))) ("frac"))
        (,(lambda (arg) (concat "√" (TeX-fold-parenthesize-as-necessary arg))) ("sqrt"))
        (,(lambda (arg) (concat "⭡" (TeX-fold-parenthesize-as-necessary arg))) ("vec"))
        ("‘{1}’" ("text"))
        ;; private commands
        ("|{1}|" ("abs"))
        ("‖{1}‖" ("norm"))
        ("⌊{1}⌋" ("floor"))
        ("⌈{1}⌉" ("ceil"))
        ("⌊{1}⌉" ("round"))
        ("𝑑{1}/𝑑{2}" ("dv"))
        ("∂{1}/∂{2}" ("pdv"))
        ;; fancification
        ("{1}" ("mathrm"))
        (,(lambda (word) (string-offset-roman-chars 119743 word)) ("mathbf"))
        (,(lambda (word) (string-offset-roman-chars 119951 word)) ("mathcal"))
        (,(lambda (word) (string-offset-roman-chars 120003 word)) ("mathfrak"))
        (,(lambda (word) (string-offset-roman-chars 120055 word)) ("mathbb"))
        (,(lambda (word) (string-offset-roman-chars 120159 word)) ("mathsf"))
        (,(lambda (word) (string-offset-roman-chars 120367 word)) ("mathtt"))
        )
      TeX-fold-macro-spec-list
      '(
        ;; as the defaults
        ("[f]" ("footnote" "marginpar"))
        ("[c]" ("cite"))
        ("[l]" ("label"))
        ("[r]" ("ref" "pageref" "eqref"))
        ("[i]" ("index" "glossary"))
        ("..." ("dots"))
        ("{1}" ("emph" "textit" "textsl" "textmd" "textrm" "textsf" "texttt"
                "textbf" "textsc" "textup"))
        ;; tweaked defaults
        ("©" ("copyright"))
        ("®" ("textregistered"))
        ("™"  ("texttrademark"))
        ("[1]:||►" ("item"))
        ("❡❡ {1}" ("part" "part*"))
        ("❡ {1}" ("chapter" "chapter*"))
        ("§ {1}" ("section" "section*"))
        ("§§ {1}" ("subsection" "subsection*"))
        ("§§§ {1}" ("subsubsection" "subsubsection*"))
        ("¶ {1}" ("paragraph" "paragraph*"))
        ("¶¶ {1}" ("subparagraph" "subparagraph*"))
        ;; extra
        ("⬖ {1}" ("begin"))
        ("⬗ {1}" ("end"))
        ))

(defun string-offset-roman-chars (offset word)
  "Shift the codepoint of each character in WORD by OFFSET with an extra -6 shift if the letter is lowercase"
  (apply 'string
         (mapcar (lambda (c)
                   (string-offset-apply-roman-char-exceptions
                    (+ (if (>= c 97) (- c 6) c) offset)))
                 word)))

(defvar string-offset-roman-char-exceptions
  '(;; lowercase serif
    (119892 .  8462) ; ℎ
    ;; lowercase caligraphic
    (119994 . 8495) ; ℯ
    (119996 . 8458) ; ℊ
    (120004 . 8500) ; ℴ
    ;; caligraphic
    (119965 . 8492) ; ℬ
    (119968 . 8496) ; ℰ
    (119969 . 8497) ; ℱ
    (119971 . 8459) ; ℋ
    (119972 . 8464) ; ℐ
    (119975 . 8466) ; ℒ
    (119976 . 8499) ; ℳ
    (119981 . 8475) ; ℛ
    ;; fraktur
    (120070 . 8493) ; ℭ
    (120075 . 8460) ; ℌ
    (120076 . 8465) ; ℑ
    (120085 . 8476) ; ℜ
    (120092 . 8488) ; ℨ
    ;; blackboard
    (120122 . 8450) ; ℂ
    (120127 . 8461) ; ℍ
    (120133 . 8469) ; ℕ
    (120135 . 8473) ; ℙ
    (120136 . 8474) ; ℚ
    (120137 . 8477) ; ℝ
    (120145 . 8484) ; ℤ
    )
  "An alist of deceptive codepoints, and then where the glyph actually resides.")

(defun string-offset-apply-roman-char-exceptions (char)
  "Sometimes the codepoint doesn't contain the char you expect.
Such special cases should be remapped to another value, as given in `string-offset-roman-char-exceptions'."
  (if (assoc char string-offset-roman-char-exceptions)
      (cdr (assoc char string-offset-roman-char-exceptions))
    char))

(defun TeX-fold-parenthesize-as-necessary (tokens &optional suppress-left suppress-right)
  "Add ❪ ❫ parenthesis as if multiple LaTeX tokens appear to be present"
  (if (TeX-string-single-token-p tokens) tokens
    (concat (if suppress-left "" "❪")
            tokens
            (if suppress-right "" "❫"))))

(defun TeX-string-single-token-p (teststring)
  "Return t if TESTSTRING appears to be a single token, nil otherwise"
  (if (string-match-p "^\\\\?\\w+$" teststring) t nil))
#+end_src

Some local keybindings to make life a bit easier
#+begin_src emacs-lisp
(after! tex
  (map!
   :map LaTeX-mode-map
   :ei [C-return] #'LaTeX-insert-item)
  (setq TeX-electric-math '("\\(" . "")))
#+end_src

Maths deliminators can be de-emphasised a bit
#+begin_src emacs-lisp
;; Making \( \) less visible
(defface unimportant-latex-face
  '((t :inherit font-lock-comment-face :weight extra-light))
  "Face used to make \\(\\), \\[\\] less visible."
  :group 'LaTeX-math)

(font-lock-add-keywords
 'latex-mode
 `((,(rx (and "\\" (any "()[]"))) 0 'unimportant-latex-face prepend))
 'end)

(font-lock-add-keywords
 'latex-mode
 `((,"\\\\[[:word:]]+" 0 'font-lock-keyword-face prepend))
 'end)
#+end_src

And enable shell escape for the preview
#+begin_src emacs-lisp
(setq preview-LaTeX-command '("%`%l \"\\nonstopmode\\nofiles\
\\PassOptionsToPackage{" ("," . preview-required-option-list) "}{preview}\
\\AtBeginDocument{\\ifx\\ifPreview\\undefined"
preview-default-preamble "\\fi}\"%' \"\\detokenize{\" %t \"}\""))
#+end_src
*** CDLaTeX
The symbols and modifies are very nice by default, but could do with a bit of
fleshing out. Let's change the prefix to a key which is similarly rarely used,
but more convenient, like =;=.
#+begin_src emacs-lisp
(after! cdlatex
  (setq ;; cdlatex-math-symbol-prefix ?\; ;; doesn't work at the moment :(
   cdlatex-math-symbol-alist
   '( ;; adding missing functions to 3rd level symbols
     (?_    ("\\downarrow"  ""           "\\inf"))
     (?2    ("^2"           "\\sqrt{?}"     ""     ))
     (?3    ("^3"           "\\sqrt[3]{?}"  ""     ))
     (?^    ("\\uparrow"    ""           "\\sup"))
     (?k    ("\\kappa"      ""           "\\ker"))
     (?m    ("\\mu"         ""           "\\lim"))
     (?c    (""             "\\circ"     "\\cos"))
     (?d    ("\\delta"      "\\partial"  "\\dim"))
     (?D    ("\\Delta"      "\\nabla"    "\\deg"))
     ;; no idea why \Phi isnt on 'F' in first place, \phi is on 'f'.
     (?F    ("\\Phi"))
     ;; now just convenience
     (?.    ("\\cdot" "\\dots"))
     (?:    ("\\vdots" "\\ddots"))
     (?*    ("\\times" "\\star" "\\ast")))
   cdlatex-math-modify-alist
   '( ;; my own stuff
     (?B    "\\mathbb"        nil          t    nil  nil)
     (?a    "\\abs"           nil          t    nil  nil))))
#+end_src
*** SyncTeX
#+begin_src emacs-lisp
(after! tex
  (add-to-list 'TeX-view-program-list '("Evince" "evince %o"))
  (add-to-list 'TeX-view-program-selection '(output-pdf "Evince")))
#+end_src
*** Fixes
In case of Emacs28,
#+begin_src emacs-lisp
(when EMACS28+
  (add-hook 'latex-mode-hook #'TeX-latex-mode))
#+end_src
** Python
Since I'm using =mypyls=, as suggested in [[file:~/.emacs.d/modules/lang/python/README.org::*Language Server Protocol Support][:lang python LSP support]] I'll tweak the
priority of =mypyls=
#+begin_src emacs-lisp
(after! lsp-python-ms
  (set-lsp-priority! 'mspyls 1))
#+end_src
Setting the anaconda home folder so emacs can find it.
#+begin_src emacs-lisp
(setq conda-anaconda-home "/opt/miniconda3"
      conda-env-home-directory "/home/yack/.conda/")
#+end_src
** PDF

=pdf-tools= is quite nice (though =paper= is looking quite promising), however
sometimes I'm in a terminal and I still want to see the content. Additionally,
sometimes I'd like to act on the content and so would like a plaintext version.

#+begin_info
This is a candidate for a dedicated package.
Let me know if you'd like to see this.
#+end_info

Thanks to src_shell{pdftotext} we have a convenient way of performing this
conversion.

#+begin_src emacs-lisp
(defun pdf-text--update (&optional _window)
  (when (eq major-mode 'pdf-text-mode)
    (let* ((converted-file (expand-file-name (concat
                                              (file-name-base buffer-file-name)
                                              "-"
                                              (substring (secure-hash 'sha1 (expand-file-name buffer-file-name)) 0 6)
                                              ".txt")
                                             temporary-file-directory))
           (width (number-to-string (- (min (window-width) fill-column)
                                       (if display-line-numbers display-line-numbers-width 0))))
           (width-adjusted-file (concat (file-name-sans-extension converted-file) "-w" width ".txt")))
      (unless (and (file-exists-p converted-file)
                   (> (time-convert (file-attribute-modification-time (file-attributes converted-file)) 'integer)
                      (time-convert (file-attribute-modification-time (file-attributes buffer-file-name)) 'integer)))
        (call-process "pdftotext" nil nil nil "-layout" "-eol" "unix" buffer-file-name converted-file))
      (unless (and (file-exists-p width-adjusted-file)
                   (>= (time-convert (file-attribute-modification-time (file-attributes width-adjusted-file)) 'integer)
                       (time-convert (file-attribute-modification-time (file-attributes converted-file)) 'integer)))
        (call-process "fmt" nil (list :file width-adjusted-file) nil "-w" width converted-file))
      (unless (and (boundp 'pdf-text--file)
                   (string= pdf-text--file width-adjusted-file))
        (let ((pos (when (boundp 'pdf-text--file) (pdf-text--position-info))))
          (with-silent-modifications
            (let ((inhibit-read-only t)
                  (coding-system-for-read 'utf-8))
              (erase-buffer)
              (insert-file-contents width-adjusted-file)
              (while (re-search-forward "\n?\f\n?" nil t)
                (replace-match "\n\f\n"))
              (goto-char (point-min)))
            (setq-local pdf-text--file width-adjusted-file))
          (setq-default saved-pos pos)
          (when pos (ignore-errors (pdf-text--goto-pos pos))))))))
#+end_src

Now we just need to make a mode to use this.

#+begin_src emacs-lisp
(define-derived-mode pdf-text-mode so-long-mode "PDF Text" ; so-long for the initial buffer load time
  "Major mode for viewing the plaintext version of a PDF."
  (set-buffer-multibyte t)
  (read-only-mode t)
  (add-hook 'before-save-hook (lambda () (user-error "Will not overwrite PDF with plaintext version")))
  (dolist (hook '(window-configuration-change-hook
                  window-size-change-functions
                  display-line-numbers-mode-hook))
    (add-hook hook 'pdf-text--update))
  (pdf-text--update)
  (text-mode)
  (setq mode-name "PDF Text"))
#+end_src

In src_elisp{(pdf-text--update)} there's mention of position saving and
restoring. This needs to be implemented, and it's a bit difficult since the line
numbers and buffer positions are liable to change. So, instead we can try to
take note of some markers (such as the line breaks) and try to make our way to
them.

#+begin_src emacs-lisp
(defun pdf-text--position-info ()
  (list :page-no (let ((current-point (point))
                       (page-no 0))
                   (save-excursion
                     (while (search-forward "\f" current-point t)
                       (setq page-no (1+ page-no))))
                   page-no)
        :par-start (save-excursion
                     (forward-paragraph -1)
                     (forward-line 1)
                     (thing-at-point 'line t))
        :previous-line-content (save-excursion
                                 (forward-line -1)
                                 (thing-at-point 'line t))))

(defun pdf-text--goto-pos (pos)
  (goto-char (point-min))
  (search-forward "\f" nil nil (plist-get pos :page-no))
  (re-search-forward (replace-regexp-in-string " +" "[ \n]+" (regexp-quote (plist-get pos :par-start))))
  (unless (string= (plist-get pos :par-start)
                   (plist-get pos :previous-line-content))
    (re-search-forward (replace-regexp-in-string " +" "[ \n]+" (regexp-quote (plist-get pos :previous-line-content)))
                       (save-excursion (forward-paragraph 1) (point)))))
#+end_src

Unfortunately while in isolated testing this position restoring works well, for
some reason as it's currently used it doesn't seem to work at all.

The output can be slightly nicer without spelling errors, and with prettier page
feeds (=^L= by default).

#+begin_src emacs-lisp
(add-hook 'pdf-text-mode-hook #'spell-fu-mode-disable)
(add-hook 'pdf-text-mode-hook (lambda () (page-break-lines-mode 1)))
#+end_src

This is very nice, now we just need to associate it with =.pdf= files, and make
sure =pdf-tools= doesn't take priority.

#+begin_src emacs-lisp
(defconst pdf-text-auto-mode-alist-entry
  '("\\.[pP][dD][fF]\\'" . pdf-text-mode)
  "The entry to use for `auto-mode-alist'.")

(defun pdf-text-install ()
  "Add a \".pdf\" associaton for all future buffers."
  (interactive)
  (add-to-list 'auto-mode-alist pdf-text-auto-mode-alist-entry)
  (when (featurep 'pdf-tools)
    (setq-default auto-mode-alist
                  (remove pdf-tools-auto-mode-alist-entry auto-mode-alist))
    (setq-default magic-mode-alist
                  (remove pdf-tools-magic-mode-alist-entry magic-mode-alist))))

(defun pdf-tools-uninstall ()
  "Remove the \".pdf\" associaton for all future buffers."
  (interactive)
  (setq-default auto-mode-alist
                (remove pdf-text-auto-mode-alist-entry auto-mode-alist)))
#+end_src

Lastly, whenever Emacs is non-graphical (i.e. a TUI), we want to use this by default.

#+begin_src emacs-lisp :tangle (if (executable-find "pdftotext") "yes" "no")
(unless (display-graphic-p)
  (pdf-text-install)
  ;; From Doom's :tools pdf (use-package! pdf-tools)
  (setq-default auto-mode-alist
                (remove '("\\.pdf\\'" . pdf-view-mode) auto-mode-alist))
  (setq-default magic-mode-alist
                (remove '("%PDF" . pdf-view-mode) magic-mode-alist))
  ;; I have no idea why this is needed
  (map! :map pdf-text-mode-map
        "<mouse-4>" (cmd! (scroll-down mouse-wheel-scroll-amount-horizontal))
        "<mouse-5>" (cmd! (scroll-up mouse-wheel-scroll-amount-horizontal))))
#+end_src

** Markdown
Let's use mixed pitch, because it's great
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'mixed-pitch-mode)
#+end_src

Most of the time when I write markdown, it's going into some app/website which
will do it's own line wrapping, hence we /only/ want to use visual line wrapping. No hard stuff.
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'visual-line-mode #'turn-off-auto-fill)
#+end_src

Since markdown is often seen as rendered HTML, let's try to somewhat mirror the
style or markdown renderers.

Most markdown renders seem to make the first three headings levels larger than
normal text, the first two much so. Then the fourth level tends to be the same
as body text, while the fifth and sixth are (increasingly) smaller, with the
sixth greyed out. Since the sixth level is so small, I'll turn up the boldness a notch.
#+begin_src emacs-lisp
(custom-set-faces!
  '(markdown-header-face-1 :height 1.25 :weight extra-bold :inherit markdown-header-face)
  '(markdown-header-face-2 :height 1.15 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-3 :height 1.08 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-4 :height 1.00 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-5 :height 0.90 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-6 :height 0.75 :weight extra-bold :inherit markdown-header-face))
#+end_src
